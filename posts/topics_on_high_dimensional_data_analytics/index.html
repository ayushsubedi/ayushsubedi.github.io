<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	
	<title>Ayush Subedi  | Topics on High-Dimensional Data Analytics (Machine Learning 2)</title>
	<meta name="viewport" content="width=device-width,minimum-scale=1">
	<meta name="generator" content="Hugo 0.128.2">
	
	
	<META NAME="ROBOTS" CONTENT="INDEX, FOLLOW">
	

		
	<title>Ayush Subedi</title>
	<meta name="title" content="Ayush Subedi">
	<meta name="description" content="… personal journey with mathematics, software engineering and data science">

	
	<meta property="og:type" content="website">
	<meta property="og:url" content="https://subedi.ml/">
	<meta property="og:title" content="Ayush Subedi">
	<meta property="og:description" content="… personal journey with mathematics, software engineering and data science">
	<meta property="og:image" content="https://subedi.ml/img/k.png">

	
	<meta property="twitter:card" content="summary_large_image">
	<meta property="twitter:url" content="https://subedi.ml/">
	<meta property="twitter:title" content="Ayush Subedi">
	<meta property="twitter:description" content="… personal journey with mathematics, software engineering and data science">
	<meta property="twitter:image" content="https://subedi.ml/img/k.png">

	
	
	<link href="/dist/app.css" rel="stylesheet">
	

	

	
	
<link rel="shortcut icon" href="/img/favicon.ico" type="image/png" />

	

	

	
	



<link rel="stylesheet" href='https://ayushsubedi.github.io/lib/katex.min.css' integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous">


<script defer src='https://ayushsubedi.github.io/lib/katex.min.js' integrity="sha384-y23I5Q6l+B6vatafAwxRu/0oK/79VlbSz7Q9aiSZUvyWYIYsd+qj+o24G5ZU2zJz" crossorigin="anonymous"></script>


<script defer src='https://ayushsubedi.github.io/lib/contrib/auto-render.min.js' integrity="sha384-kWPLUVMOks5AQFrykwIup5lo0m3iMkkHrD0uJ4H5cjeGihAutqP0yW0J6dpFiVkI"
crossorigin="anonymous"
onload='renderMathInElement(document.body);'></script>


<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

	
	
</head>

<body class="bg-gray-100 text-gray-700 font-sans">
	<div class="p-6 sm:p-10 md:p-16 flex flex-wrap">
		<header class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-1 md:order-1 max-w-2xl">
			<div
				class="z-50 bg-gray-100 bg-opacity-75 bg-opacity-custom lg:min-w-0.7 max-w-xl md:float-right md:text-right leading-loose tracking-tight md:sticky md:top-0 pt-2">
				
<div>
	<h2>
		<a href="https://ayushsubedi.github.io/" title="Ayush Subedi" class="heading font-cursive icon">Ayush Subedi</a>
	</h2>
</div>
<h1 class="pt-2">Topics on High-Dimensional Data Analytics (Machine Learning 2)</h1>

<h3 class="text-java-700 font-normal leading-relaxed pt-2">This is my note for ISYE 8803. This course focuses on analysis of high-dimensional structured data including profiles, images, and other types of functional data using statistical machine learning. A variety of topics such as functional data analysis, image processing, multilinear algebra and tensor analysis, and regularization in high-dimensional regression and its applications including low rank and sparse learning is covered. Optimization methods commonly used in statistical modeling and machine learning and their computational aspects are also discussed.</h3>

<div class="flex flex-wrap justify-end pt-2 "><div class="md:flex-grow-0 font-light">
	
	
	
	
	<a class="post-taxonomy-category text-medium-red-violet-600 hover:text-medium-red-violet-400"
		href='/categories/gatech'>gatech</a>
	
	
	

	
	&nbsp;&nbsp;
	

	
	
	
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/polynomial_regression'>polynomial_regression</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/splines'>splines</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/knn'>knn</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/regression'>regression</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/rbfkernel'>rbfkernel</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/pca'>pca</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/image_analysis'>image_analysis</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/transformation'>transformation</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/convolution'>convolution</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/segmentation'>segmentation</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/kmeans'>kmeans</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/clustering'>clustering</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/sobel_operator'>sobel_operator</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/kirsch_operator'>kirsch_operator</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/tensor_data_analysis'>tensor_data_analysis</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/kronecker_product'>kronecker_product</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/khatri_rao_product'>khatri_rao_product</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/hadamard_product'>hadamard_product</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/tucker_decomposition'>tucker_decomposition</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/optimization'>optimization</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/regularization'>regularization</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/ridge'>ridge</a>&nbsp;&#47;
	
	<a class="post-taxonomy-tag text-eucalyptus-500"
		href='/tags/lasso'>lasso</a>
	
	
	
</div><time class="text-eucalyptus-500 md:text-right md:flex-grow font-light pl-4"
		datetime="2023-11-20">2023-11-20</time>
</div>

<hr />

			</div>
		</header>
		<main role="main" class="w-full md:w-3/5 xl:w-1/2 max-w-3xl order-2 md:order-2 min-h-70vh pt-2 pb-4">
			

<article>
	<section class="mx-auto content">
		<div class="c-rich-text"><h1 id="topics-on-high-dimensional-data-analytics">Topics on High-Dimensional Data Analytics</h1>
<ol>
<li><a href="#introduction">Introduction</a></li>
<li><a href="#functional-data-analysis">Functional Data Analysis</a></li>
<li><a href="#image-analysis">Image Analysis</a></li>
<li><a href="#tensor-data-analysis">Tensor Data Analysis</a></li>
<li><a href="#optimization-and-application">Optimization and Application</a></li>
<li><a href="#regularization">Regularization</a></li>
</ol>
<h1 id="introduction">Introduction</h1>
<h3 id="big-data">Big Data</h3>
<p>Big data is a term used to describe extremely large and complex datasets that traditional data processing applications are not well-equipped to handle. The concept of &ldquo;big data&rdquo; is often associated with what is referred to as the &ldquo;4V&rdquo; framework, which describes the key characteristics of big data:</p>
<ol>
<li><strong>Volume:</strong>  This refers to the sheer scale of data generated and collected. Big data involves datasets that are too large to be managed and processed using traditional databases and tools. This massive volume can range from terabytes to petabytes and beyond.</li>
<li><strong>Velocity:</strong>  This characteristic pertains to the speed at which data is generated, collected, and processed. In today&rsquo;s fast-paced digital world, data is generated at an unprecedented rate, often in real-time or near-real-time. Examples include social media interactions, sensor data from IoT devices, financial transactions, and more.</li>
<li><strong>Variety:</strong>  Big data comes in various formats and types, such as structured, semi-structured, and unstructured data. Structured data is organized into a well-defined format (e.g., tables in a relational database), whereas unstructured data lacks a specific structure (e.g., text documents, images, videos, social media posts). Semi-structured data lies somewhere in between, having a partial structure but not fitting neatly into traditional databases.</li>
<li><strong>Veracity:</strong>  Veracity refers to the quality and reliability of the data. With the proliferation of data sources, there&rsquo;s an increased potential for data to be incomplete, inaccurate, or inconsistent. Ensuring the accuracy and trustworthiness of big data is a significant challenge, and data quality management is crucial for meaningful insights.</li>
</ol>
<h3 id="high-dimensional-data">High Dimensional Data</h3>
<p>High-dimensional data refers to datasets where the number of features or variables (dimensions) is significantly larger than the number of observations or samples. In other words, the data has a high number of attributes compared to the number of data points available. This kind of data is prevalent in various fields such as genomics, image analysis, social networks, and more.</p>
<p><img src="/img/high_dimensional_.png" alt=""></p>
<h3 id="difference-between-high-dimensional-data-and-big-data">Difference between High Dimensional Data and Big Data</h3>
<p><img src="/img/diff_bet_high_and_low.png" alt=""></p>
<p>p = dimension
n = samples</p>
<h3 id="the-curse-of-dimensionality">The Curse of Dimensionality</h3>
<blockquote>
<p>As the number of features or dimensions grows, the amount of data we need to generalize accurately grows exponentially!</p>
</blockquote>
<p><img src="/img/distance_dimension.png" alt=""></p>
<p>As distance between observations increases with the dimensions, the sample size required for learning a model drastically increases.</p>
<ol>
<li><strong>Increased Sparsity:</strong>  In higher dimensions, the available data points are spread out more thinly across the space. This means that data points become farther apart from each other, making it challenging to find meaningful clusters or patterns. It&rsquo;s like having a lot of points scattered in a large, high-dimensional space, and they&rsquo;re so spread out that it&rsquo;s difficult to identify any consistent relationships.</li>
<li><strong>More Data Needed:</strong>  With higher-dimensional data, you need a disproportionately larger amount of data to capture the underlying patterns accurately. When the data is sparse, it&rsquo;s harder to generalize from the observed points to make accurate predictions or draw conclusions. As the dimensionality increases, you might need exponentially more data to maintain the same level of accuracy in your models.</li>
<li><strong>Impact on Complexity:</strong>  The complexity of machine learning models increases with dimensionality. More dimensions mean more parameters to estimate, which can lead to overfitting – a situation where a model fits the training data too closely and fails to generalize well to new data.</li>
<li><strong>Increased Computational Demands:</strong>  Processing and analyzing high-dimensional data require more computational resources and time. Many algorithms become slower and more memory-intensive as the number of dimensions grows. This can make experimentation and model training more challenging and time-consuming.</li>
<li><strong>Difficulties in Visualization:</strong>  Our ability to visualize data effectively diminishes as the number of dimensions increases. We are accustomed to thinking in 2D and 3D space, but visualizing data in, say, 10 dimensions is practically impossible. This can make it hard to understand the structure of the data and the relationships between variables.</li>
</ol>
<h3 id="low-dimensional-learning-from-high-dimensional-data">Low Dimensional Learning From High Dimensional Data</h3>
<p>High dimensional data usually have low dimensional structure.</p>
<p><img src="https://www.mathworks.com/help/examples/stats/win64/ChangeTsneSettingsExample_01.png" alt=""></p>
<p>This can be achieved through Functional Data Analysis, Tensor Analysis, Rank Deficient Methods among others.</p>
<h3 id="solutions-for-the-curse-of-dimensionality">Solutions for the curse of dimensionality</h3>
<ul>
<li>Feature extraction</li>
<li>Dimensionality reduction</li>
<li>Collecting much more observations</li>
</ul>
<h1 id="functional-data-analysis">Functional Data Analysis</h1>
<p>A fluctuating quantity or impulse whose variations represent information and is often represented as a function of time or space.</p>
<p>From Wikipedia</p>
<blockquote>
<p><strong>Functional data analysis (FDA)</strong> is a branch of statistics that analyses data providing information about curves, surfaces or anything else varying over a continuum. In its most general form, under an FDA framework, each sample element of functional data is considered to be a random function. The physical continuum over which these functions are defined is often time, but may also be spatial location, wavelength, probability, etc. Intrinsically, functional data are infinite dimensional. The high intrinsic dimensionality of these data brings challenges for theory as well as computation, where these challenges vary with how the functional data were sampled. However, the high or infinite dimensional structure of the data is a rich source of information and there are many interesting challenges for research and data analysis.</p>
</blockquote>
<p><img src="https://lands.let.ru.nl/FDA/images/FDA_pic4website.bmp" alt=""></p>
<h2 id="regression---least-square-estimates">Regression - Least square Estimates</h2>
<p>A linear regression model assumes that the regression function $E(Y|X)$ is linear in the inputs $X_1, &hellip;, X_p$. They were developed in the pre-computer age of statistics, but even in today&rsquo;s computer era there are still good reasons to study and use them. They are simple and often provide an adequate and interpretable description of how the inputs affect the output.</p>
<p>The linear regression model has the form:</p>
<p>$f(X) = \beta_0 + \sum_{j=1}^p X_j\beta_j$</p>
<p>Typically we have a set of training data $(x_1, y_1)&hellip;(x_N, y_N)$ from which to estimate the parameters $\beta$. Each $x_i = (x_{i1}, x_{i2} &hellip; x_{ip})^T$ is a vector of feature measurements for the $i$th case. The most popular estimation method is the least squares, in which we pick the coefficients $\beta = (\beta_0, \beta_1,&hellip;.\beta_p)^T$ to minimize the residual sum of squares.</p>
<p>$\sum_{i=1}^N (y_i - f(x))^2 = \sum_{i=1}^N (y_i - \beta_0 - \sum_{j=1}^p X_j\beta_j)^2$</p>
<p><img src="/img/lr.png" alt=""></p>
<p>Denote $X$ by the $N \times (p+1)$ matrix with each row an input vector (with a 1 in the first position, to represent the intercept), and similarity let $y$ be the $N$ vector of outputs in the training set. Then we can write the residual sum-of-squares as :</p>
<p>$RSS(\beta) = (y-X\beta)^T(y-X\beta)$</p>
<p>Differentiating with respect to $\beta$, &hellip;.</p>
<p>$\hat{\beta} = (X^TX)^{-1}X^Ty$</p>
<h2 id="geometric-interpretation">Geometric Interpretation</h2>
<p>$\hat{y} = X\hat{\beta} = X(X^TX)^{-1}X^Ty = Hy $</p>
<p><strong>Projection Matrix</strong> (or Hat matrix): The outcome vector $y$ is orthogonally projected onto the hyperplane spanned by the input vectors $x_1$ and $x_2$. The Projection $\hat{y}$ represents the vector of predictions obtained by the least square method.</p>
<p><img src="/img/ols_projection.png" alt=""></p>
<h2 id="properties-of-ols">Properties of OLS</h2>
<ul>
<li>They are unbiased estimators. That is the expected value of estimators and actual parameters are the same $E(\hat{\beta}) = \beta$</li>
<li>The covariance can be obtained by $cov(\hat{\beta}) = \sigma^2 (X^TX)^{-1}$, where $\sigma^2 = SSE/(n-p)$</li>
<li>According to the <strong>Gauss-Markov Theorem</strong>, <em>among all unbiased linear estimates</em>, the least square estimate (LSE) has the minimum variance and it is unique.</li>
</ul>
<blockquote>
<p>Regression can be used for Feature Extraction</p>
</blockquote>
<h2 id="splines">Splines</h2>
<p><strong>Polynomial Regression</strong> is a type of regression analysis where the relationship between the independent variable (input) and the dependent variable (output) is modeled as an nth-degree polynomial. In other words, instead of fitting a straight line (linear regression), a polynomial regression can fit curves of various degrees, allowing for more flexibility in capturing complex relationships. For example, a quadratic polynomial regression (degree 2) can model a parabolic relationship, and a cubic polynomial regression (degree 3) can model more intricate curves.</p>
<blockquote>
<p><strong>Polynomial regression is still considered a type of linear regression</strong> because the relationship between the input and output variables is linear with respect to the coefficients, even though the input variables may be raised to different powers. The model equation for polynomial regression of degree n is:</p>
</blockquote>
<p>$y = \beta_0 + \beta_1x + \beta_2x^2 + \beta_3x^3 + &hellip; + \beta_mx^m + \epsilon$</p>
<p><strong>Nonlinear Regression</strong>, on the other hand, refers to a broader class of regression models where the relationship between the independent and dependent variables is not a linear function. Nonlinear regression can encompass a wide range of functional forms, including exponential, logarithmic, sigmoidal, and other complex shapes. The main characteristic of nonlinear regression is that the model parameters are estimated in a way that best fits the chosen nonlinear function to the data.</p>
<p>Unlike polynomial regression, nonlinear regression models can&rsquo;t be expressed in terms of a simple equation with polynomial terms. The specific form of the nonlinear function needs to be determined based on the problem&rsquo;s nature and domain knowledge.</p>
<p><strong>Disadvantages of Polynomial Regression</strong></p>
<ul>
<li>Remote part of the function is very sensitive to outliers</li>
<li>Less flexibility due to global function structure</li>
</ul>
<p><img src="/img/dis_pr.png" alt=""></p>
<blockquote>
<p>The global function structure causes underfitting or overfitting.</p>
</blockquote>
<p>The solution is to move from global to local structure -&gt; Splines.</p>
<h3 id="splines-1">Splines</h3>
<ul>
<li>Linear combination of Piecewise Polynomial Function <strong>under continuity assumption</strong></li>
<li>Partition the domain of x into continuous intervals and fit polynomials in each interval separately</li>
<li>Provides flexibility and local fitting</li>
</ul>
<p>Suppose $x \in [a,b]$. Partition the x domain using the following points (a.k.a knots):</p>
<p>$a&lt;\xi_1&lt;\xi_2&hellip;&lt;\xi_k&lt;b, &lt;\xi_0=a, &lt;\xi_{k+1}=b$</p>
<p>Fit a polynomial in each interval under the continuity conditions and integrate them by</p>
<p>$f(X) = \sum_{m=1}^K \beta_mh_m(X)$</p>
<h3 id="simple-example">Simple Example</h3>
<h3 id="piecewise-constant">Piecewise Constant</h3>
<p><img src="/img/pwc.png" alt=""></p>
<p>Here we are using a zero order polynomial. A zero order polynomial can be defined by an indicator function. If we use OLS, the beta would be the average of point in each local region.</p>
<p>$f(X) = \sum_{m=1}^3 \beta_mh_m(X)$</p>
<h3 id="piecewise-linear">Piecewise Linear</h3>
<p><img src="/img/pwl.png" alt=""></p>
<p>Here we are using a first order polynomial. A first order polynomial includes slopes and intercept (and therefore $K=6$ here.)</p>
<p>$f(X) = \sum_{m=1}^6 \beta_mh_m(X)$</p>
<p>There are two issues here:</p>
<ul>
<li>Discontinuity</li>
<li>Underfitting</li>
</ul>
<h2 id="solving-for-discontinuity">Solving for Discontinuity</h2>
<p>We can impose continuity constraint for each knot:</p>
<p>$f{\xi^-_1}=f(\xi^+_1)$</p>
<p>This can be translated to $\beta_1+\xi_1\beta_4 = \beta_2 + \xi_1\beta_5$</p>
<blockquote>
<p>Not sure how</p>
</blockquote>
<p>By adding constraints we are losing some degrees of freedom.
The total number of free parameters (degree of freedom) = 6 (total number of parameters -2 (total number of constraints) = 4</p>
<p>Alternatively, once could incorporate the constraints into the basis functions:</p>
<p>$h_1(X) = 1$,</p>
<p>$h_2(X) = X$,</p>
<p>$h_3(X) = (X-\xi_1)_+$,</p>
<p>$h_4(X) = (X-\xi_2)_+$</p>
<p>This basis is known as truncated power basis</p>
<p>$(X-\xi_k)_+ = (X-\xi_k)$ if $x \ge xi_k$ $0$ if $x&lt;xi_k$</p>
<iframe width="560" height="315" src="https://www.youtube.com/embed/790G152GYz4?si=PIkkurtDgaioUCMu" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h2 id="solving-for-underfitting">Solving for Underfitting</h2>
<p>Splines with Higher Order of Continuity can be used to tackle underfitting.</p>
<p><img src="/img/cp.png" alt=""></p>
<p>Continuity constraints for smoothness</p>
<p>$f{\xi^-_1}=f(\xi^+_1)$</p>
<p>$f^&rsquo;{\xi^-_1}=f^&rsquo;(\xi^+_1)$</p>
<p>$f^{&rsquo;&rsquo;}{\xi^-_1}=f^{&rsquo;&rsquo;}(\xi^+_1)$</p>
<p>$h_1(X) = 1$,</p>
<p>$h_2(X) = X$,</p>
<p>$h_3(X) = X^2$,</p>
<p>$h_4(X) = X^3$,</p>
<p>$h_5(X) = (X-\xi_1)^3_+$,</p>
<p>$h_6(X) = (X-\xi_2)^3_+$</p>
<p>The degree of freedom is calculated by:
Number of regions * Number of parameters in each region) - (Number of knots)*(Number of constraints per knot)</p>
<h2 id="order-m-splines">Order-M Splines</h2>
<ul>
<li>M=1 piecewise-constant splines</li>
<li>M=2 linear splines</li>
<li>M=3 quadratic splines</li>
<li>M=4 cubic splines</li>
</ul>
<p>For Truncated power basis functions:</p>
<ul>
<li>Total degree of freedom is K+M</li>
<li>Cubic spline is the lowest order spline for which the knot discontinuity is not visible to human eyes</li>
<li>Knots selection: a simple method is to use x quantiles. However, the choice of knots is a variable/model selection problem.</li>
</ul>
<h2 id="estimation">Estimation</h2>
<ul>
<li>After creating the basis function, we can use OLS to estimate parameters $\beta$</li>
<li>First of all, create a basis matrix by concatinating basis vectors. For example if we have cubic splines with two knots, we will have six basis vectors.</li>
</ul>
<p>$H = [h_1(x) \quad h_2(x) \quad h_3(x) \quad h_4(x) \quad h_5(x) \quad h_6(x)]$</p>
<p>gives $\hat\beta = (H^TH)^-1H^Ty$</p>
<p>Linear Smoother: $\hat y= H\hat\beta = H(H^TH)^{-1}H^Ty = Sy$</p>
<p>Degrees of Freedom $df=trace S$</p>
<p>Although truncated power basis functions are simple and algebraically appealing, it is not efficient for computation and ill-posed and numerically unstable. The matrix is close to singular (because of correlations among themselves, and determinant being very close to zero), and inverting it becomes challenging.</p>
<p>The solution is to user Bsplines.</p>
<h2 id="bsplines">Bsplines</h2>
<ul>
<li>Alternative basis vectors for piecewise polynomials that are computationally more efficient</li>
<li>Each basis function has a local support, that is, it is nonzero over at most M (spline order) consecutive intervals</li>
<li>The basis matrix is banded</li>
<li>The low bandwidth of the matrix reduces the linear dependency of the columns, and therefore, removes the numeric column stability.</li>
</ul>
<p><img src="/img/bspline.png" alt=""></p>
<h2 id="bspline-basis">Bspline Basis</h2>
<p>Let $B_{j,m}(x)$ be the $j^{th}$ B-spline basis function of order $m(m \le M)$ for the knot sequence $\tau$</p>
<p>$a &lt; \xi_1 &lt; \xi_2 &lt; &hellip; &lt; \xi_k &lt; b$</p>
<p>Define the augmented knots sequence $\tau$</p>
<p>$\tau_1 \le \tau_2 &hellip;\le \tau_M \le \xi_0$ (before the lower bound)</p>
<p>$\tau_{M+j} = \xi_j, j = 1, &hellip; , K$</p>
<p>$\xi_{K+1} \le \tau_{M+K+1} \le \tau_{M+K+2} \le &hellip; \le \tau_{2M+K}$ (after the lower bound)</p>
<h3 id="smoother-matrix">Smoother Matrix</h3>
<p>Consider a regression Spline basis B</p>
<p>$\hat f = B(B^TB)^{-1}B^Ty = Hy$</p>
<ul>
<li>H is the smoother matrix (projection matrix)</li>
<li>H is idempotent ($H \times H = H$)</li>
<li>H is symmetric</li>
<li>Degrees of freedom trace (H)</li>
</ul>
<h2 id="smoothing-splines">Smoothing Splines</h2>
<h3 id="bspline-basis-boundary-issue">Bspline basis boundary issue</h3>
<p>Consider the following setting with the fixed training data</p>
<p>$y_i = f(x_i) + \epsilon_i$</p>
<p>$\epsilon_i \approx iid(0, \sigma^2)$</p>
<p>$Var(\hat f(x)) = h(x)^T(H^TH)^{-1}h(x)\sigma^2$ (variance of estimated function using spline)</p>
<blockquote>
<p>Behavior of splines tends to be sporadic near the boundaries, and extrapolation can be problematic. The main reason is that the complexity of Cubic Spline is more than the complexity of Global Cubic Polynomial, due to the large number of parameters (less bias, more variance). The solution is to use linear splines instead of cubic splines (Natural Cubic Splines).</p>
</blockquote>
<h2 id="natural-cubic-splines">Natural Cubic Splines</h2>
<ul>
<li>Additional constraints are added to make the function linear beyond the boundary knots</li>
<li>Assuming the function is linear near the boundaries (where there is less information) is often reasonable</li>
<li>Cubic spline; linear on $[-\inf, \xi_1]$ and $[\xi_k , \inf]$</li>
<li>Prediction variance decreases</li>
<li>The price is the bias near the boundaries</li>
<li>Degrees of freedom is K, the number of knots</li>
<li>Each of these basis functions has zero second and third derivative in the linear region.</li>
</ul>
<h2 id="penalized-residual-sum-of-squares">Penalized residual sum of squares</h2>
<p>$\min_f \frac{1}{n}\sum_{i-1}^n[y_i - f(x_i)]^2+\lambda \int^a_b[f^{&quot;}(x)^2dx]$</p>
<ul>
<li>The first term measures the closeness of the model to the data (related to bias)</li>
<li>The second term penalizes curvature of the function (related to variance)</li>
<li>$\lambda$ is the smoothing parameter controlling the trade between bias and variance</li>
<li>$\lambda = 0$ interpolate the data (overfitting)</li>
<li>$\lambda = \inf$ linear least-square regression (underfitting)</li>
</ul>
<p>It can be shown that the minimizer is a natural cubic spline.</p>
<p>Solution: $\hat \theta = (N^TN + \lambda\Omega)^{-1}N^Ty$
, $\Omega$ represents the second derivative</p>
<p>$ f = (N^TN + \lambda\Omega)^{-1}N^Ty = S_\lambda y$</p>
<ul>
<li>Smoothing spline estimator is a linear smoother</li>
<li>$S_\lambda$ is the smoother matrix</li>
<li>$S_\lambda$ is NOT idempotent</li>
<li>$S_\lambda$ is symmetric</li>
<li>$S_\lambda$ is positive definite</li>
<li>Degrees of freedom: trace($S_\lambda$)</li>
</ul>
<h2 id="choice-of-tuning-parameters">Choice of Tuning Parameters</h2>
<ul>
<li>
<p>Train Test Validation
<img src="/img/pt.png" alt=""></p>
</li>
<li>
<p>Cross Validation
If an independent validation dataset is not affordable, the K-fold cross validation or leave-one-out CV can be useful</p>
</li>
<li>
<p>Akaike Information Criteria (AIC)</p>
</li>
<li>
<p>Bayesian Information Criteria (BIC)</p>
</li>
<li>
<p>Generalized Cross-validation</p>
</li>
</ul>
<h2 id="kernel-smoothers">Kernel Smoothers</h2>
<h3 id="k-nearest-neighbor-knn">K-Nearest Neighbor (KNN)</h3>
<p>KNN Average $\hat f(x_0) = \sum_{i=1}^nw(x_0, x_i)y_i$</p>
<p>where $\sum_{i=1}^nw(x_0, x_i)$ = $\frac{1}{K}$ if $x_i \in N_k(x_0)$ else $0$</p>
<ul>
<li>Simple average of the k nearest observations to $x_0$ (local averaging)</li>
<li>Equal weights are assigned to all neighbors</li>
<li>However, the fitted function is in the form of a step function (non-smooth function)</li>
<li>Also, the bias is quite high</li>
</ul>
<h3 id="kernel-function">Kernel Function</h3>
<p>Any non-negative real-valued integrable function that satisfies the following conditions:</p>
<ul>
<li>$\int_{-\inf}^{\inf}K(u)du=1$</li>
<li>K is an even function; $K(-u) = K(u)$</li>
<li>It has a finite second moment; $u^2\int_{-\inf}^{\inf}K(u)du &lt; \inf$</li>
</ul>
<h3 id="kernel-smoother-regression">Kernel Smoother Regression</h3>
<p><strong>Kernel Regression</strong></p>
<ul>
<li>Is weighted local averaging that fits a simple model separately at each query point $x_0$</li>
<li>More weights are assigned to closer observation</li>
<li>Localization is defined by the weighting function</li>
<li>Kernel regression requires little training, all calculations get done at the evaluation time.</li>
</ul>
<p><img src="/img/kregression.png" alt=""></p>
<h3 id="choice-of-lambda">Choice of $\lambda$</h3>
<ul>
<li>$\lambda$ defines the width of the neighbourhood</li>
<li>Only points withing $[x_0-\lambda, x_0+\lambda]$ receive positive weights</li>
<li>Smaller $\lambda$: rough estimate, larger bias, smaller variance</li>
<li>Larger $\lambda$: smoother estimate, smaller bias, larger variance</li>
</ul>
<p>Cross-validation can be used for determining of $\lambda$:</p>
<h3 id="drawbacks-of-local-averaging">Drawbacks of Local Averaging</h3>
<ul>
<li>The local averaging can be biased on the boundaries of the domain due to the asymmetry of the kernel in that region.</li>
<li>This can be solved by local linear regression</li>
</ul>
<p><img src="/img/nw_kernel.png" alt=""></p>
<ul>
<li>Local linear regression corrects the bias on the boundaries</li>
<li>Local polynomial regression corrects the bias in the curvature region</li>
<li>However, local polynomial regression is complex due to higher order of polynomials, therefore, it increases the prediction variance.</li>
<li>A good solution would be to use local linear model for points in the boundaries, and local quadratic regression in the interior regions.</li>
</ul>
<h2 id="functional-principal-component">Functional Principal Component</h2>
<p>Similar to PCA, FPCA aims to reduce the dimension of functional data by extracting a small set of uncorrelated features, which capture the most of the variation.</p>
<p>Functional data (observed signals) are comprised of two main components. The first component is the continuous functional mean, and the second component is the error term, that is, the realizations from a stochastic process with mean function 0 and covariance function $C(t, t^&rsquo;)$. It includes both random noise and signal-to-signal variations</p>
<p>$s_i(t) = \mu(t) + \epsilon_i(t)$</p>
<p>The mean function is common across all signals (notice that it does not have the $i$ subscript)</p>
<p>Since signal variance comes from the noise function, we first focus on this for dimensionality reduction using the Karhunen-Loeve Theorem.</p>
<p><img src="/img/kl.png" alt=""></p>
<p>The variance of $\xi_{ik}$ quickly decays with k. Therefore, only a few $\xi_{ik}$ also known as FPC-scores, would be enough to accurately approximate the noise function. That is,</p>
<p>$\epsilon_i(t) \approx \sum_{k=1}^K \xi_{ik}\phi_{k}(t)$</p>
<p>Signals decomposition is given by</p>
<p>$s_i(t) = \mu(t) + \epsilon_i(t) \implies \mu(t) + \sum_{k=1}^K \xi_{ik}\phi_{k}(t)$</p>
<h2 id="model-estimation">Model Estimation</h2>
<p>Both the mean and covariance is unknown, and should be measured using training data. In practice, we have two types of signals/data:</p>
<ul>
<li>Complete signals: Sampled regularly</li>
<li>Incomplete signals: Sampled irregularly, sparse, fragmented</li>
</ul>
<h2 id="steps-for-fpca-when-the-signals-are-incomplete">Steps for FPCA when the signals are incomplete:</h2>
<ul>
<li>Estimate the mean function using local linear regression</li>
<li>Estimate the raw covariance function using the estimated mean function</li>
<li>Estimate the covariance surface using local quadratic regression</li>
<li>Compute the Eigen functions</li>
<li>Compute the FPC scores</li>
</ul>
<h1 id="image-analysis">Image Analysis</h1>
<h2 id="introduction-to-image-processing">Introduction to Image Processing</h2>
<ul>
<li>The process of processing raw images and extracting useful information for decision making.</li>
<li><strong>Level 0:</strong> Image representation (acquisition, sampling, quantization, compression)</li>
<li><strong>Level 1:</strong> Image to Image transformations (enhancement, filtering, restoration, smoothing, segmentation)</li>
<li><strong>Level 2:</strong> Image to vector transformation (feature extraction and dimension reduction)</li>
<li><strong>Level 3:</strong> Feature to decision mapping</li>
</ul>
<p><img src="/img/image_analysis.png" alt=""></p>
<h2 id="what-is-an-image">What is an Image?</h2>
<p>A gray (color-RGB) image is a 2-D (3-D) light intensity function, $f (x_1, x_2)$, where $f$ measures brightness at position $f(x_1, x_2)$ . A digital gray (color) image is a representation of an image by a 2-D (3-D) array of discrete samples. <strong>Pixel</strong> is referred to an element of the array.</p>
<p>Possible values each pixel can have:</p>
<ul>
<li>Black and white image: 2</li>
<li>8-bit Gray image: 256</li>
<li>RGB: 256 x 256 x 256 = 16777216</li>
</ul>
<h2 id="basic-manipulation-in-python">Basic Manipulation in Python</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> cv2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Load the image</span>
</span></span><span style="display:flex;"><span>image_path <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;your_image.jpg&#39;</span>  <span style="color:#75715e"># Replace with the path to your image</span>
</span></span><span style="display:flex;"><span>original_image <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>imread(image_path)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Check if the image was loaded successfully</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> original_image <span style="color:#f92672">is</span> <span style="color:#66d9ef">None</span>:
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Error: Could not open or find the image.&#34;</span>)
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert the image to grayscale</span>
</span></span><span style="display:flex;"><span>    gray_image <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>cvtColor(original_image, cv2<span style="color:#f92672">.</span>COLOR_BGR2GRAY)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Convert the grayscale image to black and white using thresholding</span>
</span></span><span style="display:flex;"><span>    _, binary_image <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>threshold(gray_image, <span style="color:#ae81ff">128</span>, <span style="color:#ae81ff">255</span>, cv2<span style="color:#f92672">.</span>THRESH_BINARY)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Resize the image (e.g., to a width of 800 pixels while maintaining aspect ratio)</span>
</span></span><span style="display:flex;"><span>    new_width <span style="color:#f92672">=</span> <span style="color:#ae81ff">800</span>
</span></span><span style="display:flex;"><span>    aspect_ratio <span style="color:#f92672">=</span> original_image<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">/</span> original_image<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>    new_height <span style="color:#f92672">=</span> int(new_width <span style="color:#f92672">/</span> aspect_ratio)
</span></span><span style="display:flex;"><span>    resized_image <span style="color:#f92672">=</span> cv2<span style="color:#f92672">.</span>resize(binary_image, (new_width, new_height))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># Save the processed images to disk</span>
</span></span><span style="display:flex;"><span>    cv2<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">&#39;gray_image.jpg&#39;</span>, gray_image)
</span></span><span style="display:flex;"><span>    cv2<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">&#39;black_and_white_image.jpg&#39;</span>, binary_image)
</span></span><span style="display:flex;"><span>    cv2<span style="color:#f92672">.</span>imwrite(<span style="color:#e6db74">&#39;resized_image.jpg&#39;</span>, resized_image)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Images processed and saved successfully.&#34;</span>)
</span></span></code></pre></div><h2 id="image-transformation">Image Transformation</h2>
<h3 id="image-histogram">Image Histogram</h3>
<ul>
<li>Histogram represents the distribution of gray levels.</li>
<li>It is an estimate of the probability density function (pdf) of the underlying random process.</li>
</ul>
<p>Image can be transformed by applying a function on the image matrix.</p>
<p>$g(x,y) = T(f(x,y))$</p>
<p>For example if a threshold function is sued as the transformation function a gray-scale image can be converted to a BW image.</p>
<p><img src="/img/step_function.png" alt=""></p>
<ul>
<li>The brightness of an image can be changed by shifting its histogram.</li>
<li>The contrast of an image is defined by the difference in maximum and minimum pixel intensity.</li>
<li>Gray level resolution refers to change in the shades or levels of gray in an image.</li>
<li>The number of different colors in an image depends on bits per pixel (bpp).</li>
</ul>
<p>$L = 2^{bpp}$</p>
<ul>
<li>Gray level transformation is often used for image enchantment.</li>
<li>Three typical transformation functions are:
<ul>
<li>Linear (negative image)</li>
<li>Log</li>
<li>Power-Law</li>
</ul>
</li>
</ul>
<h3 id="convolution-and-image-filtering">Convolution and image filtering</h3>
<p>The convolution of functions $f$ and $g$ is defined by:</p>
<p><img src="/img/convolutions.png" alt=""></p>
<ul>
<li>Convolution is widely used in image processing for denoising, blurring, sharpening, embossing, and edge detection.</li>
<li>Image filter is a convolution of a mask (aka kernel, and convolution matrix) with an image that can be used for blurring, sharpening, edge detection, etc.</li>
<li>A mask is a matrix convolved with an image.</li>
</ul>
<h3 id="image-convolution-with-a-mask">Image Convolution with a Mask</h3>
<ul>
<li>Flip the mask (kernel) both horizontally and vertically.</li>
<li>Put the center element of the mask at every pixel of the image. Multiply the corresponding elements and then add them up. Replace the pixel value corresponding to the center of the mask with the resulting sum.</li>
</ul>
<p><img src="/img/convolution.png" alt=""></p>
<ul>
<li>For pixels on the border of image matrix, some elements of the mask might fall out of the image matrix. In this case, we can extend the image by adding zeros. This is known as padding.</li>
</ul>
<p><img src="/img/padding.png" alt=""></p>
<h3 id="denoising-of-smooth-images-using-splines">Denoising of Smooth Images using Splines</h3>
<ul>
<li>Another approach for denoising smooth images is to use local regression with smooth basis (eg. splines)</li>
<li>Using Kronecker product, a 2D-spline basis can be generated from 1D basis matrices</li>
</ul>
<h2 id="image-segmentation">Image Segmentation</h2>
<ul>
<li>The main goal of image segmentation is to partition an image into multiple sets of pixels (segments)</li>
<li>Image segmentation has been widely used for object detection, face and fingerprint recognition, medical imaging, video surveillance, etc.</li>
<li>Various methods exist for image segmentation including:
<ul>
<li>Local and global thresholding</li>
<li>Otsu&rsquo;s method</li>
<li>K-means clustering</li>
</ul>
</li>
<li>Thresholding is a simple segmentation approach that converts grayscale image to binary image by applying the thresholding function on histogram.</li>
</ul>
<h3 id="otsus-method">Otsu&rsquo;s Method</h3>
<ul>
<li>The goal is to automatically determine the threshold $t$ given an image histogram.</li>
</ul>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/3/34/Otsu%27s_Method_Visualization.gif/440px-Otsu%27s_Method_Visualization.gif" alt=""></p>
<p>Steps:</p>
<ul>
<li>Get the histogram of the image</li>
<li>Calculate group mean and variance</li>
<li>Find the maximum value for the variance</li>
<li>Threshold the image</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">compute_otsu_criteria</span>(im, th):
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Otsu&#39;s method to compute criteria.&#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># create the thresholded image</span>
</span></span><span style="display:flex;"><span>    thresholded_im <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(im<span style="color:#f92672">.</span>shape)
</span></span><span style="display:flex;"><span>    thresholded_im[im <span style="color:#f92672">&gt;=</span> th] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># compute weights</span>
</span></span><span style="display:flex;"><span>    nb_pixels <span style="color:#f92672">=</span> im<span style="color:#f92672">.</span>size
</span></span><span style="display:flex;"><span>    nb_pixels1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>count_nonzero(thresholded_im)
</span></span><span style="display:flex;"><span>    weight1 <span style="color:#f92672">=</span> nb_pixels1 <span style="color:#f92672">/</span> nb_pixels
</span></span><span style="display:flex;"><span>    weight0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span> weight1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># if one of the classes is empty, eg all pixels are below or above the threshold, that threshold will not be considered</span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># in the search for the best threshold</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> weight1 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span> <span style="color:#f92672">or</span> weight0 <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>inf
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># find all pixels belonging to each class</span>
</span></span><span style="display:flex;"><span>    val_pixels1 <span style="color:#f92672">=</span> im[thresholded_im <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>    val_pixels0 <span style="color:#f92672">=</span> im[thresholded_im <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># compute variance of these classes</span>
</span></span><span style="display:flex;"><span>    var1 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>var(val_pixels1) <span style="color:#66d9ef">if</span> len(val_pixels1) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>    var0 <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>var(val_pixels0) <span style="color:#66d9ef">if</span> len(val_pixels0) <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0</span> <span style="color:#66d9ef">else</span> <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> weight0 <span style="color:#f92672">*</span> var0 <span style="color:#f92672">+</span> weight1 <span style="color:#f92672">*</span> var1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>im <span style="color:#f92672">=</span> <span style="color:#75715e"># load your image as a numpy array.</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># For testing purposes, one can use for example im = np.random.randint(0,255, size = (50,50))</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># testing all thresholds from 0 to the maximum of the image</span>
</span></span><span style="display:flex;"><span>threshold_range <span style="color:#f92672">=</span> range(np<span style="color:#f92672">.</span>max(im)<span style="color:#f92672">+</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>criterias <span style="color:#f92672">=</span> [compute_otsu_criteria(im, th) <span style="color:#66d9ef">for</span> th <span style="color:#f92672">in</span> threshold_range]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># best threshold is the one minimizing the Otsu criteria</span>
</span></span><span style="display:flex;"><span>best_threshold <span style="color:#f92672">=</span> threshold_range[np<span style="color:#f92672">.</span>argmin(criterias)]
</span></span></code></pre></div><h3 id="k-means-clustering-method">K-Means Clustering Method</h3>
<p>K-means clustering is a method for partitioning a set of observations to K clusters, such that the within-cluster variation is minimized.</p>
<ul>
<li>Rearrange the image pixels such that the number of rows in the resulting matrix is equal to the number of pixels and the number of columns is the same as the number of color channels</li>
<li>Randomly select K centers</li>
<li>Assign each pixel to the closest cluster</li>
<li>Update the cluster mean</li>
<li>Repeat the last two process until convergence</li>
</ul>
<blockquote>
<p>The objective of K-means is to minimize the within cluster variation, and maximize the inter-class variation.</p>
</blockquote>
<h3 id="edge-detection">Edge Detection</h3>
<ul>
<li>Edges are significant local changes of intensity in an image.</li>
<li>Edge Detection: Detect pixel with sudden intensity change</li>
<li>Often points that lie on an edge are detected by:
<ul>
<li>Detecting the local <strong>maxima</strong> or <strong>minima</strong> of the first derivative.</li>
<li>Detecting the <strong>zero-crossings</strong> of the second derivative.</li>
</ul>
</li>
</ul>
<p><img src="/img/edge.png" alt=""></p>
<h3 id="sobel-operator">Sobel Operator</h3>
<p>The Sobel operator works by convolving an image with a pair of 3x3 kernels or filters, one for detecting edges in the horizontal direction (often referred to as the Sobel-X operator) and the other for detecting edges in the vertical direction (often referred to as the Sobel-Y operator). These kernels are as follows:</p>
<p>Sobel-X Kernel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Sobel-Y Kernel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">2</span>  <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h3 id="krisch-operator">Krisch Operator</h3>
<p>Krisch is another derivative mask that finds the maximum edge strength in eight directions of a compass.</p>
<p><img src="/img/kirsh.png" alt=""></p>
<blockquote>
<p>It is more time consuming compare to Sobel</p>
</blockquote>
<h3 id="prewitt-mask">Prewitt Mask</h3>
<p>The Prewitt operator, like the Sobel operator, employs a pair of 3x3 convolution kernels, one for detecting edges in the horizontal direction and the other for detecting edges in the vertical direction.</p>
<p>Here are the two Prewitt kernels:</p>
<p>Prewitt-X Kernel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><p>Prewitt-Y Kernel:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span> <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">1</span>
</span></span></code></pre></div><h3 id="laplacian-and-laplacian-of-gaussian-mask">Laplacian and Laplacian of Gaussian Mask</h3>
<ul>
<li>Laplacian mask is a second order derivative mask.</li>
<li>For noisy images, is combined with a Gaussian mask to reduce the noise</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">1</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">4</span>  <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span><span style="color:#ae81ff">0</span>  <span style="color:#ae81ff">1</span>  <span style="color:#ae81ff">0</span>
</span></span></code></pre></div><blockquote>
<p>Laplacian, Sobel, and Prewitt are masks used for edge detection. Gaussian is not a mask for edge detection.</p>
</blockquote>
<h1 id="tensor-data-analysis">Tensor Data Analysis</h1>
<h2 id="tensor-introduction">Tensor Introduction</h2>
<p>A tensor is an algebraic object that describes a multi-linear relationship between sets of algebraic objects related to a vector space. Tensors may map between different objects such as vectors, scalars, and even other tensors.</p>
<p><img src="https://hkilter.com/images/7/7a/Tensors.png" alt=""></p>
<h3 id="terminologies">Terminologies:</h3>
<h4 id="order">Order</h4>
<p>The order of a tensor refers to the number of indices or subscripts needed to specify its components in a given coordinate system. Tensors can have different orders, and the order determines their mathematical properties and how they transform under coordinate transformations. Here&rsquo;s a brief overview of tensor orders:</p>
<p><strong>Zeroth-Order Tensor (Scalar)</strong>: A zeroth-order tensor is also known as a scalar. It has no indices and represents a single numerical value. Scalars are invariant under coordinate transformations.</p>
<blockquote>
<p>Example: Temperature at a point in space.</p>
</blockquote>
<p><strong>First-Order Tensor (Vector)</strong>: A first-order tensor, also known as a vector, has one index. Vectors represent quantities with both magnitude and direction and transform linearly under coordinate transformations.</p>
<blockquote>
<p>Example: Velocity, force, displacement.</p>
</blockquote>
<p><strong>Second-Order Tensor (Matrix)</strong>: A second-order tensor has two indices. It represents a linear transformation that maps one vector to another. Matrices are used to represent various physical quantities, such as stress tensors, moment of inertia tensors, and more.</p>
<blockquote>
<p>Example: Stress tensor, moment of inertia tensor.</p>
</blockquote>
<p><strong>Third-Order Tensor:</strong> A third-order tensor has three indices, and it is used to represent more complex relationships between vectors and matrices. These tensors are less common but can arise in various physical and mathematical contexts.</p>
<blockquote>
<p>Example: Piezoelectric tensor in materials science.</p>
</blockquote>
<p><img src="/img/tensor_order.png" alt=""></p>
<h4 id="fibers">Fibers</h4>
<p>A fiber, the higher order analogue of matrix row and column, is defined by fixing every index but one, e.g.,</p>
<ul>
<li>A matrix column is a mode-1 fiber and a matrix row is a mode-2 fiber</li>
<li>Third-order tensors have column, row, and tube fibers</li>
<li>Extracted fibers from a tensor are assumed to be oriented as column vectors.</li>
</ul>
<p><img src="/img/fibers.png" alt=""></p>
<h4 id="slices">Slices</h4>
<p>Two-dimensional sections of a tensor, defined by fixing all but two indices.</p>
<p><img src="/img/slices.png" alt=""></p>
<h4 id="norm">Norm</h4>
<p>Norm of a tensor $X \in \R^{I_1 \times I_2 \times &hellip;. \times I_N}$ is the square root of the sum of the squares of all its elements.</p>
<p>This is analogous to the matrix Frobenius norm, which is denoted $||A||_F$ for matrix $A$</p>
<h4 id="outer-product">Outer Product</h4>
<p>A multi-way vector outer product is a tensor where each element is the product of corresponding elements in vectors</p>
<p><img src="/img/outer_product.png" alt=""></p>
<h4 id="inner-product">Inner Product</h4>
<p>The inner product of two tensors is a generalization of the dot product operation for vectors as calculated by dot. A dot product operation (multiply and sum) is performed on all corresponding dimensions in the tensors, so the operation returns a scalar value. For this operation, the tensors must have the same size.</p>
<p><img src="/img/innter_product.png" alt=""></p>
<h4 id="using-tensorly-for-inner-and-outer-product">Using Tensorly for inner and outer product</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the shape of the random tensors</span>
</span></span><span style="display:flex;"><span>shape <span style="color:#f92672">=</span> (<span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate random data for X and Y using NumPy</span>
</span></span><span style="display:flex;"><span>X_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#f92672">*</span>shape)
</span></span><span style="display:flex;"><span>Y_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#f92672">*</span>shape)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Convert the NumPy arrays to TensorLy tensors</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(X_data)
</span></span><span style="display:flex;"><span>Y <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(Y_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calculate the inner product of X and Y</span>
</span></span><span style="display:flex;"><span>inner_product <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tenalg<span style="color:#f92672">.</span>inner(X, Y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Calculate the outer product of X and Y</span>
</span></span><span style="display:flex;"><span>outer_product <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tenalg<span style="color:#f92672">.</span>outer(X, Y)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the results</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Inner Product:&#34;</span>)
</span></span><span style="display:flex;"><span>print(inner_product)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Outer Product:&#34;</span>)
</span></span><span style="display:flex;"><span>print(outer_product)
</span></span></code></pre></div><h4 id="using-tensorly-for-unfolding-and-flattening">Using Tensorly for unfolding, and flattening</h4>
<blockquote>
<p>Unfold an N-way tensor into a matrix</p>
</blockquote>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random 2x2x2 tensor</span>
</span></span><span style="display:flex;"><span>random_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>tensor <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(random_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Mode-1 matricization (unfold along the first mode)</span>
</span></span><span style="display:flex;"><span>mode1_matricization <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>unfold(tensor, mode<span style="color:#f92672">=</span><span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Mode-2 matricization (unfold along the second mode)</span>
</span></span><span style="display:flex;"><span>mode2_matricization <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>unfold(tensor, mode<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Mode-3 matricization (unfold along the third mode)</span>
</span></span><span style="display:flex;"><span>mode3_matricization <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>unfold(tensor, mode<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the results</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Mode-1 Matricization:&#34;</span>)
</span></span><span style="display:flex;"><span>print(mode1_matricization)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Mode-2 Matricization:&#34;</span>)
</span></span><span style="display:flex;"><span>print(mode2_matricization)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Mode-3 Matricization:&#34;</span>)
</span></span><span style="display:flex;"><span>print(mode3_matricization)
</span></span></code></pre></div><p><img src="/img/matrixization.png" alt=""></p>
<h2 id="tensor-multiplication">Tensor Multiplication</h2>
<p>The n-mode product is referred to as multiplying a tensor by a matrix (or a vector) in mode n.</p>
<p>The n-mode (matrix) product of a tensor $X \in \R^{I_1 \times I_2 \times &hellip;. \times I_N}$ with a matrix $U \in R^{J \times I_n}$ is denoted by $X \times_n U$ and is of size $I_1 \times I_2 \times &hellip;. \times I_{n-1} \times J \times I_{n+1} \times &hellip;\times I_N $</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random 3x2x4 tensor</span>
</span></span><span style="display:flex;"><span>random_tensor_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>tensor <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(random_tensor_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random matrix compatible with mode-1 multiplication</span>
</span></span><span style="display:flex;"><span>random_matrix_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">5</span>)
</span></span><span style="display:flex;"><span>matrix <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(random_matrix_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Multiply the tensor and matrix in mode-1</span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tenalg<span style="color:#f92672">.</span>mode_dot(tensor, matrix, mode<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the result</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Random Tensor:&#34;</span>)
</span></span><span style="display:flex;"><span>print(tensor)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Random Matrix:&#34;</span>)
</span></span><span style="display:flex;"><span>print(matrix)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Result of Mode-1 Multiplication:&#34;</span>)
</span></span><span style="display:flex;"><span>print(result)
</span></span></code></pre></div><h4 id="n-mode-vector-product">n-Mode Vector Product</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random 3x2x4 tensor</span>
</span></span><span style="display:flex;"><span>random_tensor_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>)
</span></span><span style="display:flex;"><span>tensor <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(random_tensor_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random vector compatible with mode-1 multiplication</span>
</span></span><span style="display:flex;"><span>random_vector_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>vector <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(random_vector_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Multiply the tensor and vector in mode-1</span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tenalg<span style="color:#f92672">.</span>mode_dot(tensor, vector, mode<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the random tensor, random vector, and the result of Mode-1 multiplication</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Random Tensor:&#34;</span>)
</span></span><span style="display:flex;"><span>print(tensor)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Random Vector:&#34;</span>)
</span></span><span style="display:flex;"><span>print(vector)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">Result of Mode-1 Multiplication:&#34;</span>)
</span></span><span style="display:flex;"><span>print(result)
</span></span></code></pre></div><h4 id="kronecker-product">Kronecker Product</h4>
<p>The Kronecker product, denoted by ⊗, is a mathematical operation that combines two matrices to create a larger matrix. It is a tensor product of two matrices and results in a block matrix where each block is a scalar multiple of one of the elements of the first matrix, multiplied by the second matrix.</p>
<p>The Kronecker Product of matrices $A \in R^{I \times J}$ and $B \in R^{K \times L}$ is denoted by $A \bigotimes B$. The result is a matrix size ($IK) \times (JL)$ and defined by</p>
<p><img src="/img/kronecker.png" alt=""></p>
<h4 id="examples">Examples</h4>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/74fc4867467d053ae700ebb040ddfbe42600288c" alt=""></p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1d5453c59a261174eb2458c21ff9bdd30dc2c87d" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create two matrices</span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]])
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Compute the Kronecker product</span>
</span></span><span style="display:flex;"><span>kronecker_product <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>kron(A, B)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the result</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Kronecker Product:&#34;</span>)
</span></span><span style="display:flex;"><span>print(kronecker_product)
</span></span></code></pre></div><h4 id="khatri-rao-product">Khatri-Rao Product</h4>
<p>The Khatri-Rao product, also known as the column-wise Kronecker product or simply the Khatri-Rao product, is an operation on two matrices that results in a matrix. It&rsquo;s used in various applications in signal processing and linear algebra, especially in multilinear models and factorization problems. The Khatri-Rao product is denoted by ⊙.</p>
<p>Given two matrices, A of size m x n and B of size p x n, the Khatri-Rao product of A and B results in a matrix C of size (m * p) x n, where each column of C is formed by taking the Kronecker product of the corresponding columns of A and B.</p>
<h4 id="example">Example</h4>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/311fb96a2459096ea05d8f0461e67a8b49f5ee43" alt=""></p>
<p>so that:</p>
<p><img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/1e951f306d0dd52a9a56a35d767f2117db8a5ee6" alt=""></p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create two matrices A and B</span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>], [<span style="color:#ae81ff">5</span>, <span style="color:#ae81ff">6</span>]])
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>], [<span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">9</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Compute the Khatri-Rao product</span>
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>kron(A, B)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the result</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Khatri-Rao Product:&#34;</span>)
</span></span><span style="display:flex;"><span>print(C)
</span></span></code></pre></div><blockquote>
<p>If a and b are vectors, then the Khatri-Rao and Kronecker products are identical</p>
</blockquote>
<h4 id="hadamard-product">Hadamard Product</h4>
<p>The Hadamard product, also known as the element-wise product or Schur product, is an operation between two matrices or vectors of the same size, resulting in another matrix or vector of the same size. In this operation, each element of the resulting matrix is the product of the corresponding elements of the input matrices. It is denoted by ⊙.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create two matrices or vectors of the same size</span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]])
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">5</span>], [<span style="color:#ae81ff">6</span>, <span style="color:#ae81ff">7</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Compute the Hadamard product</span>
</span></span><span style="display:flex;"><span>C <span style="color:#f92672">=</span> A <span style="color:#f92672">*</span> B
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Print the result</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Hadamard Product:&#34;</span>)
</span></span><span style="display:flex;"><span>print(C)
</span></span></code></pre></div><h2 id="tensor-decomposition">Tensor Decomposition</h2>
<iframe width="100%" height="315" src="https://www.youtube.com/embed/L8uT6hgMt00?si=l6KQPaHQk80f7Nh9" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
<h3 id="rank-one-tensor">Rank-One Tensor</h3>
<p>A Rank-One Tensor can be created by the outer product of multiple vectors, e.g., a 3-order rank-one tensor is obtained by</p>
<p><img src="/img/outer_product.png" alt=""></p>
<h3 id="candecompparafac-cp-decomposition">Candecomp/Parafac (CP) Decomposition</h3>
<p>Candecomp/Parafac (CP)(Parallel Factor Analysis) decomposition is a tensor decomposition method used in multilinear algebra and multivariate data analysis. It is an extension of the matrix factorization technique, like Singular Value Decomposition (SVD), to higher-order tensors, often referred to as multi-way arrays.</p>
<p>The CP decomposition factorizes a tensor into a sum of component rank-one tensors, e.g. given a third-order tensor $X \in R^{I \times J\ times K}$, CP decomposition is given by,</p>
<p>$X \approx \sum_{r=1}^{R} a_r \cdot b_r \cdot c_r$</p>
<p>$R$ is a positive integer.</p>
<blockquote>
<p>If R is the rank of higher-tensor then CP decomposition will be exact and unique.</p>
</blockquote>
<h3 id="rank-of-tensor">Rank of Tensor</h3>
<p>Rank of a tensor $X$, denoted by $rank(X)$ is the smallest number of rank-one tensors whose sum can generate $X$</p>
<blockquote>
<p>Determining the rank of a tensor is an NP-hard problem. Some weaker upper bounds, however, exits that helps restrict the rank space. For example,</p>
</blockquote>
<p>$X^{I \times J \times K}$,</p>
<p>$rank(X)$ $\le min(IJ,JK, IK)$</p>
<h3 id="cp-decomposition-in-python">CP Decomposition in Python</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the dimensions of the tensor</span>
</span></span><span style="display:flex;"><span>I <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>J <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>K <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random tensor with the specified dimensions</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(I, J, K)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Set the desired rank for the decomposition</span>
</span></span><span style="display:flex;"><span>rank <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Perform CP decomposition using TensorLy</span>
</span></span><span style="display:flex;"><span>factors <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>decomposition<span style="color:#f92672">.</span>parafac(X, rank<span style="color:#f92672">=</span>rank)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reconstruct the original tensor</span>
</span></span><span style="display:flex;"><span>reconstructed_X <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>kruskal_to_tensor(factors)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Evaluate the reconstruction error</span>
</span></span><span style="display:flex;"><span>reconstruction_error <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>norm(X <span style="color:#f92672">-</span> reconstructed_X, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Reconstruction Error: </span><span style="color:#e6db74">{</span>reconstruction_error<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><h2 id="tucker-decomposition">Tucker Decomposition</h2>
<blockquote>
<p>Tucker Decomposition is <strong>not</strong> a special case of CP Decomposition</p>
</blockquote>
<p>Tucker decomposition, also known as Tucker factorization or Tucker model, is a tensor decomposition method used to represent a multi-dimensional tensor as a core tensor and a set of factor matrices that capture the relationships between the tensor&rsquo;s modes or dimensions. Tucker decomposition is a higher-order extension of matrix factorization techniques like Singular Value Decomposition (SVD) to tensors.</p>
<p>In Tucker decomposition, a given tensor is approximated as the product of a core tensor and a set of factor matrices for each mode. The core tensor contains the most important information about the original tensor&rsquo;s structure, while the factor matrices capture how each mode contributes to the overall tensor. Here&rsquo;s an overview of the Tucker decomposition process:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> tensorly <span style="color:#66d9ef">as</span> tl
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the dimensions of the tensor</span>
</span></span><span style="display:flex;"><span>shape <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">5</span>)  <span style="color:#75715e"># Change these dimensions according to your data</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Create a random tensor with the specified dimensions</span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tensor(np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#f92672">*</span>shape))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Specify the Tucker rank (adjust these values as needed)</span>
</span></span><span style="display:flex;"><span>rank <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Perform Tucker decomposition using TensorLy</span>
</span></span><span style="display:flex;"><span>core, factors <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>decomposition<span style="color:#f92672">.</span>tucker(X, rank<span style="color:#f92672">=</span>rank)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Reconstruct the original tensor</span>
</span></span><span style="display:flex;"><span>reconstructed_X <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>tucker_to_tensor(core, factors)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Evaluate the reconstruction error</span>
</span></span><span style="display:flex;"><span>reconstruction_error <span style="color:#f92672">=</span> tl<span style="color:#f92672">.</span>norm(X <span style="color:#f92672">-</span> reconstructed_X, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;Reconstruction Error: </span><span style="color:#e6db74">{</span>reconstruction_error<span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span>)
</span></span></code></pre></div><h1 id="optimization-and-application">Optimization and Application</h1>
<p>In plain English, <strong>optimization</strong> is the action of making the best or most effective use of a situation or resource. Optimization problems are of great practical interest. For example, in manufacturing, how should one cut plates of a material so that the waste is minimized? In business, how should a company allocate the available resources that its profit is maximized? Some of the first optimization problems have been solved in ancient Greece and are regarded among the most significant discoveries of that time. In the first century A.D., the Alexandrian mathematician Heron solved the problem of finding the shortest path between two points by way of the mirror.</p>
<p>This result, also known as Heron’s theorem of the light ray, can be viewed as the origin of the theory of geometrical optics. The problem of finding extreme values gained special importance in the seventeenth century, when it served as one of the motivations in the invention of differential calculus, which is the foundation of the modern theory of mathematical optimization.</p>
<h2 id="generic-form-of-optimization-problem">Generic form of optimization problem:</h2>
<p>$min$ $f(x)$ $s.t.$ $x \in X $</p>
<ul>
<li>The vector $x = (x_1, . . . , x_n)$ is the optimization variable (or decision variable) of the problem</li>
<li>The function $f$ is the objective function</li>
<li>A vector $x$ is called optimal, or a solution (not optimal solution) of the problem, if it has the smallest objective value among all vectors that satisfy the constraints</li>
<li>$X$ is the set of inequality constraints</li>
</ul>
<h3 id="mathematical-ingredients">Mathematical ingredients:</h3>
<ul>
<li>Encode decisions/actions as <strong>decision variables</strong> whose values we are seeking</li>
<li>Identify the relevant <strong>problem data</strong></li>
<li>Express <strong>constraints</strong> on the values of the decision variables as mathematical relationships (inequalities) between the variables and problem data</li>
<li>Express the <strong>objective function</strong> as a function of the decision variables and the problem data.</li>
</ul>
<p><strong>Minimize or Maximize an objective function of decision variable subject to constraints on the values of the decision variables.</strong></p>
<pre tabindex="0"><code>min or max f(x1, x2, .... , xn)
subject to gi(x1, x2, ...., ) &lt;= bi     i = 1,....,m 
        xj is continuous or discrete    j = 1,....,n
</code></pre><h3 id="the-problem-setting">The problem setting</h3>
<ul>
<li>Finite number of decision variables</li>
<li>A single objective function of decision variables and problem data
<ul>
<li>Multiple objective functions are handled by either taking a weighted combination of them or by optimizing one of the objectives while ensuring the other objectives meet target requirements.</li>
</ul>
</li>
<li>The constraints are defined by a finite number of inequalities or equalities involving functions of the decision variables and problem data</li>
<li>There may be domain restrictions (continuous or discrete) on some of the variables</li>
<li>The functions defining the objective and constraints are algebraic (typically with rational coefficients)</li>
</ul>
<h3 id="minimization-vs-maximization">Minimization vs Maximization</h3>
<ul>
<li>Without the loss of generality, it is sufficient to consider a minimization objective since maximization of objective function is minimization of the negation of the objective function</li>
</ul>
<h3 id="program-vs-optimization">Program vs Optimization</h3>
<ul>
<li>A program or mathematical program is an optimization problem with a finite number of variables and constraints written out using explicit mathematical (algebraic) expressions</li>
<li>The word program means plan/planning</li>
<li>Early application of optimization arose in planning resource allocations and gave rise to programming to mean optimization (predates computer programming)</li>
</ul>
<h3 id="example-designing-a-box">Example: Designing a box:</h3>
<p><strong>Given a $1$ feet by $1$ feet piece of cardboard, cut out corners and fold to make a box of maximum volume:</strong><br/>
<strong>Decision:</strong> $x$ = how much to cut from each of the corners?<br/>
<strong>Alternatives:</strong> $0&lt;=x&lt;=1/2$<br/>
<strong>Best:</strong> Maximize volume: $V(x) = x(1-2x)^2$ ($x$ is the height and $(1-2x)^2$ is the base, and their product is the volume)<br/>
<strong>Optimization formulation:</strong> $max$ $x(1-2x)^2$ subject to $0&lt;=x&lt;=1/2$ (which are the constraints in this case)<br/></p>
<iframe src="https://www.desmos.com/calculator/ily45jyfsv?embed" width="100%" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
<p>This is an unconstrained optimization problem since the constraint is a simple bound based.</p>
<h3 id="example-data-fitting">Example: Data Fitting:</h3>
<p><strong>Given $N$ data points $(y_1, x_1)&hellip;(y_N, x_N)$ where $y_i$ belongs to $\mathbb{R}$ and $x_i$ belongs to $\mathbb{R}^n$, for all $i = 1..N$, find a line $y = a^Tx+b$ that best fits the data.</strong><br/>
<strong>Decision</strong>: A vector $a$ that belongs to $\mathbb{R}^n$ and a scalar $b$ that belongs to $\mathbb{R}$<br/>
<strong>Alternatives</strong>: All $n$-dimensional vectors and scalars<br/>
<strong>Best</strong>: Minimize the sum of squared errors<br/>
<strong>Optimization formulation</strong>:
$\begin{array}{ll}\min &amp; \sum_{i=1}^N\left(y_i-a^{\top} x_i-b\right)^2 \ \text { s.t. } &amp; a \in \mathbb{R}^n, b \in \mathbb{R}\end{array}$</p>
<p>This is also an unconstrained optimization problem.</p>
<h3 id="example-product-mix">Example: Product Mix:</h3>
<p><strong>A firm make $n$ different products using $m$ types of resources. Each unit of product $i$ generates $p_i$ dollars of profit, and requires $r_{ij}$ units of resource $j$. The firm has $u_j$ units of resource $j$ available. How much of each product should the firm make to maximize profits?</strong><br/>
<strong>Decision</strong>: how much of each product to make<br/>
<strong>Alternatives</strong>: defined by the resource limits<br/>
<strong>Best</strong>: Maximize profits<br/>
<strong>Optimization formulation:</strong> <br/>
Sum notation: $\begin{array}{lll}\max &amp; \sum_{i=1}^n p_i x_i \ \text { s.t. } &amp; \sum_{i=1}^n r_{i j} x_i \leq u_j &amp; \forall j=1, \ldots, m \ &amp; x_i \geq 0 &amp; \forall i=1, \ldots, n\end{array}$ <br/>
Matrix notation: $\begin{array}{cl}\max &amp; p^{\top} x \ \text { s.t. } &amp; R x \leq u \ &amp; x \geq 0\end{array}$</p>
<h3 id="example-project-investment">Example: Project investment</h3>
<p><strong> A firm is considering investing in $n$ different R&amp;D projects. Project $j$ requires an investment of $c_j$ dollars and promises a return of $r_j$ dollars. The firm has a budget of $B$ dollars. Which projects should the firm invest in?</strong><br/>
<strong>Decision</strong>: Whether or not to invest in project<br/>
<strong>Alternatives</strong>: Defined by budget<br/>
<strong>Best</strong>: Maximize return on investment<br/>
Sum notation: $\begin{aligned} \max &amp; \sum_{j=1}^n r_j x_j \ \text { s.t. } &amp; \sum_{j=1}^n c_j x_j \leq B \ &amp; x_j \in{0,1} \forall j=1, \ldots, n\end{aligned}$ <br/>
Matrix notation: $\begin{aligned} \max  &amp; r^{\top} x \ \text { s.t. } &amp; c^{\top} x \leq B \ &amp; x \in{0,1}^n\end{aligned}$</p>
<p>This is not an unconstrained problem.</p>
<ul>
<li>Identify basic portfolio optimization and associated issues</li>
<li>Examine the Markowitz Portfolio Optimization approach
<ul>
<li><strong>Markowitz Principle</strong>: Select a portfolio that attempts to maximize the expected return and minimize the variance of returns (risk)</li>
</ul>
</li>
<li>For multi objective problem (like defined by the Markowitz Principle), two objectives can be combined:
<ul>
<li>Maximize Expected Return - $\lambda$*risk</li>
<li>Maximize Expected Return subject to risk &lt;= s_max (constraint on risk)</li>
<li>Minimize Risk subject to return &gt;= r_min (threshold on expected returns)</li>
</ul>
</li>
<li>Optimization Problem Statement</li>
</ul>
<pre tabindex="0"><code>Given $1000, how much should we invest in each of the three stocks MSFT, V and WMT so as to :
- have a one month expected return of at least a given threshold
- minimize the risk(variance) of the portfolio return
</code></pre><ul>
<li><strong>Decision</strong>: investment in each stock</li>
<li><strong>alternatives</strong>: any investment that meets the budget and the minimum expected return requirement</li>
<li>best: minimize variance</li>
<li><strong>Key trade-off</strong>: How much of the detail of the actual problem to consider while maintaining computational tractability of the mathematical model?</li>
<li>Requires making simplifying assumptions, either because some of the problem characteristics are not well-defined mathematically, or because we wish to develop a model that can actually be solved</li>
<li>Need to exercise great caution in these assumptions and not loose sight of the true underlying problem</li>
<li><strong>Assumptions</strong>:
<ul>
<li>No transaction cost</li>
<li>Stocks does not need to be bought in blocks (any amount &gt;=0 is fine)</li>
</ul>
</li>
<li><strong>Optimization Process</strong>: Decision Problem -&gt; Model -&gt; Data Collection -&gt; Model Solution -&gt; Analysis -&gt; Problem solution</li>
<li>No clear cut recipe</li>
<li>Lots of feedbacks and iterations</li>
<li>Approximations and assumptions involved in each stage</li>
<li>Success requires good understanding of the actual problem (domain knowledge is important)</li>
</ul>
<h2 id="classification-of-optimization-problems">Classification of optimization problems</h2>
<ul>
<li>The tractability of a large scale optimization problem depends on the structure of the functions that make up the objective and constraints, and the domain restrictions on the variables.</li>
</ul>
<table>
<thead>
<tr>
<th>Functions</th>
<th>Variable domains</th>
<th>Problem Type</th>
<th>Difficulty</th>
</tr>
</thead>
<tbody>
<tr>
<td>All linear</td>
<td>Continuous variables</td>
<td>Linear Program</td>
<td>Easy</td>
</tr>
<tr>
<td>Some nonlinear</td>
<td>Continuous variables</td>
<td>Nonlinear Program or Nonlinear Optimization Problem</td>
<td>Easy/Difficult</td>
</tr>
<tr>
<td>Linear/nonlinear</td>
<td>Some discrete</td>
<td>Integer Problem or Discrete Optimization Problem</td>
<td>Difficult</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Optimization Problem</th>
<th>Description</th>
<th>Difficulty</th>
</tr>
</thead>
<tbody>
<tr>
<td>Linear Programming</td>
<td>A linear programming problem involves maximizing or minimizing a linear objective function subject to a set of linear constraints</td>
<td>Easy to moderate</td>
</tr>
<tr>
<td>Nonlinear Programming</td>
<td>A nonlinear programming problem involves optimizing a function that is not linear, subject to a set of nonlinear constraints</td>
<td>Moderate to hard</td>
</tr>
<tr>
<td>Quadratic Programming</td>
<td>A quadratic programming problem involves optimizing a quadratic objective function subject to a set of linear constraints</td>
<td>Moderate</td>
</tr>
<tr>
<td>Convex Optimization</td>
<td>A convex optimization problem involves optimizing a convex function subject to a set of linear or convex constraints</td>
<td>Easy to moderate</td>
</tr>
<tr>
<td>Integer Programming</td>
<td>An integer programming problem involves optimizing a linear or nonlinear objective function subject to a set of linear or nonlinear constraints, where some or all of the variables are restricted to integer values</td>
<td>Hard</td>
</tr>
<tr>
<td>Mixed-integer Programming</td>
<td>A mixed-integer programming problem is a generalization of integer programming where some or all of the variables can be restricted to integer values or continuous values</td>
<td>Hard</td>
</tr>
<tr>
<td>Global Optimization</td>
<td>A global optimization problem involves finding the global optimum of a function subject to a set of constraints, which may be nonlinear or non-convex</td>
<td>Hard</td>
</tr>
<tr>
<td>Stochastic Optimization</td>
<td>A stochastic optimization problem involves optimizing an objective function that depends on random variables, subject to a set of constraints</td>
<td>Hard</td>
</tr>
</tbody>
</table>
<h3 id="subclasses-of-nlp-non-linear-problem">Subclasses of NLP (Non Linear Problem)</h3>
<ul>
<li><strong>Unconstrained optimization</strong>: No constraints or simple bound constraints on the variables (Box design example above)</li>
<li><strong>Quadratic programming</strong>: Objectives and constraints involve quadratic functions (Data fitting example above), <strong>subset of NLP</strong></li>
</ul>
<h3 id="subclasses-of-ip-integer-programming">Subclasses of IP (Integer Programming)</h3>
<ul>
<li><strong>Mixed Integer Linear Program</strong>
<ul>
<li>All linear functions</li>
<li>Some variables are continuous and some are discrete</li>
</ul>
</li>
<li><strong>Mixed Integer Nonlinear Program (MINLP)</strong>
<ul>
<li>Some nonlinear functions</li>
<li>Some variables are continuous and some are discrete</li>
</ul>
</li>
<li><strong>Mixed Integer Quadratic Program (MIQLP)</strong>
<ul>
<li>Nonlinear functions are quadratic</li>
<li>Some variables are continuous and some are discrete</li>
<li>subset of MINLP</li>
</ul>
</li>
</ul>
<h3 id="why-and-how-to-classify">Why and how to classify?</h3>
<ul>
<li>Important to recognize the type of an optimization problem:
<ul>
<li>to formulate problems to be amenable to certain solution methods</li>
<li>to anticipate the difficulty of solving the problem</li>
<li>to know which solution methods to use</li>
<li>to design customized solution methods</li>
</ul>
</li>
<li>how to classify:
<ul>
<li>check domain restriction on variables</li>
<li>check the structure of the functions involved</li>
</ul>
</li>
</ul>
<h3 id="taylor-approximation">Taylor Approximation</h3>
<p>The Taylor series of a real or complex-valued function f (x) that is infinitely differentiable at a real or complex number a is the power series.</p>
<p>Let $f: \mathbb{R}^n \rightarrow \mathbb{R}$ be a differentiable function and $\mathbf{x}^0 \in \mathbb{R}^n$.</p>
<ul>
<li>First order Taylor&rsquo;s approximation of $f$ at $\mathbf{x}^0$ :
$$
f(\mathbf{x}) \approx f\left(\mathbf{x}^0\right)+\nabla f\left(\mathbf{x}^0\right)^{\top}\left(\mathbf{x}-\mathbf{x}^0\right)
$$</li>
<li>Second order Taylor&rsquo;s approximation of $f$ at $\mathbf{x}^0$ :
$$
f(\mathbf{x}) \approx f\left(\mathbf{x}^0\right)+\nabla f\left(\mathbf{x}^0\right)^{\top}\left(\mathbf{x}-\mathbf{x}^0\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}^0\right)^{\top} \nabla^2 f\left(\mathbf{x}^0\right)\left(\mathbf{x}-\mathbf{x}^0\right)
$$
`</li>
</ul>
<h3 id="sets-in-optimization-problems">Sets in Optimization Problems</h3>
<ul>
<li>A set is <strong>closed</strong> if it includes its boundary points.</li>
<li>Intersection of closed sets is closed.</li>
<li>Typically, if none of inequalities are strict, then the set is closed.</li>
<li>A set is convex if a line segment connecting two points in the set lies entirely in the set.</li>
<li>A set is bounded if it can be enclosed in a large enough (hyper)-sphere or a box.</li>
<li>A set that is both bounded and closed is called compact.
<ul>
<li>$R^2$ is closed but not bounded</li>
<li>$x^2+y^2&lt;1$ is bounded but not closed</li>
<li>$x+y&gt;=1$ is closed but not bounded</li>
<li>$x^2+y^2&lt;=1$ is closed and bounded (compact)</li>
</ul>
</li>
<li>An optimal solution of maximizing a convex function over a compact set lies on the boundary
of the set.</li>
</ul>
<iframe src="https://www.desmos.com/calculator/49e59msg7u?embed" width="100%" height="500" style="border: 1px solid #ccc" frameborder=0></iframe>
<h3 id="convex-function">Convex Function</h3>
<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/c/c7/ConvexFunction.svg/1280px-ConvexFunction.svg.png" alt=""></p>
<ul>
<li>A function $f: \mathbb{R}^n \rightarrow \mathbb{R}$ is convex if
$$
f(\lambda \mathbf{x}+(1-\lambda) \mathbf{y}) \leq \lambda f(\mathbf{x})+(1-\lambda) f(\mathbf{y}) \quad \forall \mathbf{x}, \mathbf{y} \in \mathbb{R}^n \text { and } \lambda \in[0,1]
$$</li>
<li><strong>&ldquo;Function value at the average is less than the average of the function values&rdquo;</strong></li>
<li>This also implies that $a^Tx+b$ is convex (and concave)</li>
<li>For a convex function the first order Taylor&rsquo;s approximation is a global under estimator</li>
<li>A convex optimization problem has a convex objective and convex set of solutions.</li>
<li>Linear programs (LPs) can be seen as a special case of convex optimization problems. In an LP, the objective function and constraints are linear, which means that the feasible region defined by the constraints is a convex set. As a result, the optimal solution to an LP is guaranteed to be at a vertex (corner) of the feasible region, which makes it a convex optimization problem.</li>
<li>A twice differentiable univariate function is convex if $f^{&rsquo;&rsquo;}(x)&gt;=0$ for all $x \in R$</li>
<li>To generalize, a twice differentiable function is convex if and only if the Hessian matrix is positive semi definite.</li>
<li>A positive semi-definite (PSD) matrix is a matrix that is symmetric and has non-negative eigenvalues. In the context of a Hessian matrix, it represents the second-order partial derivatives of a multivariate function and reflects the curvature of the function. If the Hessian is PSD, it indicates that the function is locally convex, meaning that it has a minimum value in the vicinity of that point. On the other hand, if the Hessian is not PSD, the function may have a saddle point or be locally non-convex. The PSD property of a Hessian matrix is important in optimization, as it guarantees the existence of a minimum value for the function.</li>
<li><strong>Sylvester&rsquo;s criterion</strong> is a method for determining if a matrix is positive definite or positive semi-definite. The criterion states that a real symmetric matrix is positive definite if and only if all of its leading principal minors (i.e. determinants of the submatrices formed by taking the first few rows and columns of the matrix) are positive. If all the leading principal minors are non-negative, then the matrix is positive semi-definite.</li>
</ul>
<h2 id="first-order-methods">First Order Methods</h2>
<h3 id="gradient-descent">Gradient descent</h3>
<p>Gradient descent is an iterative optimization algorithm used to find the minimum of a function, typically used in machine learning and deep learning to update the parameters of a model during training. The basic idea behind gradient descent is to adjust the parameters in the direction of steepest descent (negative gradient) to minimize a cost or loss function. Here&rsquo;s a detailed explanation of gradient descent:</p>
<ol>
<li><strong>Objective Function</strong> : Gradient descent begins with an objective function (also called a cost or loss function) that you want to minimize. In machine learning, this function typically represents the error between the model&rsquo;s predictions and the actual data.</li>
</ol>
<p>Let&rsquo;s denote the objective function as $J(θ)$, where $θ$ represents a vector of parameters that we want to optimize.</p>
<ol start="2">
<li>
<p><strong>Initialization</strong> : You start by initializing the parameter vector θ with some arbitrary values or often with random values. This is the starting point of the optimization process.</p>
</li>
<li>
<p><strong>Gradient Calculation</strong> : Calculate the gradient of the objective function with respect to the parameters. The gradient is a vector that points in the direction of the steepest increase in the function. Mathematically, the gradient is represented as:</p>
</li>
</ol>
<p>$(\nabla J(\theta) = \left[\frac{\partial J(\theta)}{\partial \theta_1}, \frac{\partial J(\theta)}{\partial \theta_2}, \ldots, \frac{\partial J(\theta)}{\partial \theta_n}\right])
$</p>
<p>Here, $∂J(θ)/∂θ_i$ represents the partial derivative of $J(θ)$ with respect to the i-th parameter $θ_i$.</p>
<ol start="4">
<li><strong>Update Parameters</strong> : Update the parameters θ using the gradient. The update rule is as follows:</li>
</ol>
<p>$θ_{new} = θ_{old} - α * ∇J(θ_{old})$</p>
<p>Where:</p>
<ul>
<li>$θ_{new}$ is the updated parameter vector.</li>
<li>$θ_{old}$ is the current parameter vector.</li>
<li>$α$ (alpha) is the learning rate, a hyperparameter that controls the step size or how much to move in the direction of the gradient. It&rsquo;s a small positive value typically chosen in advance.</li>
</ul>
<p>This step is performed iteratively until a stopping criterion is met.</p>
<ol start="5">
<li>
<p><strong>Stopping Criterion</strong> : The algorithm continues to update the parameters and compute the gradient until a stopping criterion is satisfied. Common stopping criteria include a maximum number of iterations, a minimum change in the objective function, or when the gradient becomes close to zero.</p>
</li>
<li>
<p><strong>Convergence</strong> : Gradient descent converges when it reaches a local or global minimum of the objective function, or when it satisfies the stopping criterion. The choice of learning rate (α) and the convergence behavior are important aspects to consider when using gradient descent.</p>
</li>
</ol>
<p>There are variations of gradient descent, including:</p>
<ul>
<li><strong>Batch Gradient Descent</strong> : In each iteration, it computes the gradient using the entire dataset. This can be computationally expensive for large datasets.</li>
<li><strong>Stochastic Gradient Descent (SGD)</strong> : In each iteration, it computes the gradient using only one random data point from the dataset. It&rsquo;s faster but has more noise in its updates.</li>
<li><strong>Mini-batch Gradient Descent</strong> : It uses a small random subset (mini-batch) of the dataset in each iteration, striking a balance between the computational efficiency of SGD and the stability of batch gradient descent.</li>
<li><strong>Momentum, Adagrad, RMSprop, and Adam</strong> : These are advanced optimization techniques that incorporate additional mechanisms to improve convergence speed and stability.</li>
</ul>
<p>The choice of the specific gradient descent variant and its hyperparameters depends on the problem at hand, the dataset, and computational resources. Proper tuning of the learning rate and monitoring convergence is crucial for successful optimization.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gradient_descent</span>(obj_func, gradient_func, initial_theta, learning_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>, max_iterations<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, tolerance<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-5</span>):
</span></span><span style="display:flex;"><span>    theta <span style="color:#f92672">=</span> initial_theta
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> iteration <span style="color:#f92672">in</span> range(max_iterations):
</span></span><span style="display:flex;"><span>        gradient <span style="color:#f92672">=</span> gradient_func(theta)
</span></span><span style="display:flex;"><span>        theta <span style="color:#f92672">=</span> theta <span style="color:#f92672">-</span> learning_rate <span style="color:#f92672">*</span> gradient
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Calculate the magnitude of the gradient for convergence check</span>
</span></span><span style="display:flex;"><span>        gradient_magnitude <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(gradient)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> gradient_magnitude <span style="color:#f92672">&lt;</span> tolerance:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Converged after </span><span style="color:#e6db74">{</span>iteration<span style="color:#e6db74">}</span><span style="color:#e6db74"> iterations.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> theta
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">objective_function</span>(theta):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> theta[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> theta[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gradient_function</span>(theta):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> theta[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> theta[<span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial parameters</span>
</span></span><span style="display:flex;"><span>initial_theta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">4.0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Call gradient descent</span>
</span></span><span style="display:flex;"><span>final_theta <span style="color:#f92672">=</span> gradient_descent(objective_function, gradient_function, initial_theta)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Optimal parameters:&#34;</span>, final_theta)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Minimum value of the objective function:&#34;</span>, objective_function(final_theta))
</span></span></code></pre></div><h3 id="accelerated-gradient-descent">Accelerated Gradient Descent</h3>
<p>Accelerated Gradient Descent, also known as Nesterov Accelerated Gradient (NAG) or simply Nesterov momentum, is an optimization algorithm that improves upon the standard gradient descent by adding momentum to the updates. This momentum helps the algorithm converge faster and provides better stability, especially in the presence of noisy gradients. Here&rsquo;s how it works:</p>
<ol>
<li><strong>Initialization</strong> : Initialize the parameter vector θ with some arbitrary values, and initialize the momentum vector <code>v</code> to zero.</li>
<li><strong>Update Momentum (v)</strong> : In each iteration, before computing the gradient, update the momentum vector <code>v</code> using the previous momentum and the gradient from the previous iteration. This is the key difference between NAG and traditional momentum.</li>
</ol>
<p>$v_t = γ * v_{t-1} + α * ∇J(θ_{t-1} - γ * v_{t-1})$</p>
<ul>
<li>$γ$ is the momentum coefficient (typically a value close to 0.9).</li>
<li>$α$ is the learning rate.</li>
<li>$∇J(θ_{t-1} - γ * v_{t-1})$ is the gradient of the loss function evaluated at the updated position using the momentum.</li>
</ul>
<ol start="3">
<li><strong>Update Parameters (θ)</strong> : Update the parameters θ using the momentum <code>v</code> computed in the previous step.</li>
</ol>
<p>$θ_t = θ_{t-1} - v_t$</p>
<ol start="4">
<li><strong>Repeat</strong> : Repeat steps 2 and 3 until a stopping criterion is met, such as a maximum number of iterations or a small gradient magnitude.</li>
</ol>
<p>The key insight in Nesterov Accelerated Gradient Descent is that it calculates the gradient at a &ldquo;lookahead&rdquo; position by subtracting the previous momentum-scaled update from the current parameters before computing the gradient. This lookahead helps in achieving smoother convergence by reducing oscillations.</p>
<p>Here&rsquo;s a Python implementation of Nesterov Accelerated Gradient Descent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">nesterov_accelerated_gradient_descent</span>(obj_func, gradient_func, initial_theta, learning_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>, momentum<span style="color:#f92672">=</span><span style="color:#ae81ff">0.9</span>, max_iterations<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, tolerance<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-5</span>):
</span></span><span style="display:flex;"><span>    theta <span style="color:#f92672">=</span> initial_theta
</span></span><span style="display:flex;"><span>    v <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros_like(initial_theta)
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> iteration <span style="color:#f92672">in</span> range(max_iterations):
</span></span><span style="display:flex;"><span>        gradient <span style="color:#f92672">=</span> gradient_func(theta <span style="color:#f92672">-</span> momentum <span style="color:#f92672">*</span> v)
</span></span><span style="display:flex;"><span>        v <span style="color:#f92672">=</span> momentum <span style="color:#f92672">*</span> v <span style="color:#f92672">+</span> learning_rate <span style="color:#f92672">*</span> gradient
</span></span><span style="display:flex;"><span>        theta <span style="color:#f92672">=</span> theta <span style="color:#f92672">-</span> v
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Calculate the magnitude of the gradient for convergence check</span>
</span></span><span style="display:flex;"><span>        gradient_magnitude <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(gradient)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> gradient_magnitude <span style="color:#f92672">&lt;</span> tolerance:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Converged after </span><span style="color:#e6db74">{</span>iteration<span style="color:#e6db74">}</span><span style="color:#e6db74"> iterations.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> theta
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define your objective function and gradient function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">objective_function</span>(theta):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> theta[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> theta[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gradient_function</span>(theta):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> theta[<span style="color:#ae81ff">0</span>], <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> theta[<span style="color:#ae81ff">1</span>]])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial parameters</span>
</span></span><span style="display:flex;"><span>initial_theta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">4.0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Call Nesterov Accelerated Gradient Descent</span>
</span></span><span style="display:flex;"><span>final_theta <span style="color:#f92672">=</span> nesterov_accelerated_gradient_descent(objective_function, gradient_function, initial_theta)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Optimal parameters:&#34;</span>, final_theta)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Minimum value of the objective function:&#34;</span>, objective_function(final_theta))
</span></span></code></pre></div><p>In this implementation, <code>momentum</code> is the momentum coefficient (typically close to 0.9), and <code>learning_rate</code> is the step size. The rest of the algorithm follows the Nesterov Accelerated Gradient Descent procedure described earlier.</p>
<h3 id="stochastic-gradient-descent-sgd">Stochastic Gradient Descent (SGD)</h3>
<p>Stochastic Gradient Descent (SGD) is an optimization algorithm used for training machine learning models, particularly in cases where you have a large dataset. Unlike traditional gradient descent, which computes the gradient of the cost function using the entire dataset in each iteration, SGD updates the model&rsquo;s parameters by considering only a single randomly chosen data point (or a small batch of data points) in each iteration. This makes it much faster and enables it to handle large datasets.</p>
<p>Here&rsquo;s how Stochastic Gradient Descent works:</p>
<ol>
<li><strong>Initialization</strong> : Start with an initial guess for the model&rsquo;s parameters, often set to small random values.</li>
<li><strong>Shuffling</strong> : Shuffle the training dataset randomly. This step ensures that the data points are processed in a random order in each epoch (a complete pass through the dataset).</li>
<li><strong>Iterative Update</strong> : For each iteration:</li>
</ol>
<ul>
<li>Select a random data point (or a small mini-batch) from the shuffled dataset.</li>
<li>Compute the gradient of the loss function with respect to the model&rsquo;s parameters using only the selected data point (or mini-batch).</li>
<li>Update the model&rsquo;s parameters in the opposite direction of the gradient:</li>
</ul>
<p>$θ = θ - learningrate * gradient$</p>
<p>Where:</p>
<ul>
<li><code>θ</code> represents the model&rsquo;s parameters.</li>
<li><code>learningrate</code> is a positive scalar called the learning rate, which controls the step size in the parameter update.</li>
<li><code>gradient</code> is the gradient of the loss function with respect to the parameters computed using the selected data point (or mini-batch).</li>
</ul>
<ol start="4">
<li><strong>Repeat</strong> : Continue this process for a fixed number of iterations (epochs) or until a stopping criterion is met.</li>
</ol>
<p>SGD has several advantages, including:</p>
<ul>
<li>Efficiency: It&rsquo;s computationally efficient because it uses only one or a few data points at a time, making it suitable for large datasets.</li>
<li>Regularization: The inherent randomness in SGD acts as a form of regularization, which can help prevent overfitting.</li>
<li>Escape Local Minima: The noise introduced by using individual data points can help the algorithm escape local minima in the loss landscape.</li>
</ul>
<p>However, SGD can have high variance in its parameter updates because of the noisy gradient estimates, which can lead to oscillations and slow convergence. To address this, variations of SGD have been developed, including Mini-batch Gradient Descent, which uses small random mini-batches of data, and techniques like learning rate schedules and momentum to stabilize and accelerate convergence.</p>
<p>Here&rsquo;s a simple Python implementation of Stochastic Gradient Descent:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">stochastic_gradient_descent</span>(obj_func, gradient_func, initial_theta, learning_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>, max_epochs<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, tolerance<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-5</span>):
</span></span><span style="display:flex;"><span>    theta <span style="color:#f92672">=</span> initial_theta
</span></span><span style="display:flex;"><span>    num_examples <span style="color:#f92672">=</span> len(obj_func)  <span style="color:#75715e"># Number of data points</span>
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> epoch <span style="color:#f92672">in</span> range(max_epochs):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Shuffle the data for each epoch</span>
</span></span><span style="display:flex;"><span>        shuffled_indices <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>permutation(num_examples)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> shuffled_indices:
</span></span><span style="display:flex;"><span>            gradient <span style="color:#f92672">=</span> gradient_func(theta, i)
</span></span><span style="display:flex;"><span>            theta <span style="color:#f92672">=</span> theta <span style="color:#f92672">-</span> learning_rate <span style="color:#f92672">*</span> gradient
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Calculate the magnitude of the gradient for convergence check</span>
</span></span><span style="display:flex;"><span>            gradient_magnitude <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(gradient)
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> gradient_magnitude <span style="color:#f92672">&lt;</span> tolerance:
</span></span><span style="display:flex;"><span>                print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Converged after </span><span style="color:#e6db74">{</span>epoch<span style="color:#e6db74">}</span><span style="color:#e6db74"> epochs.&#34;</span>)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> theta
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Did not converge.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> theta
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial parameters</span>
</span></span><span style="display:flex;"><span>initial_theta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">3.0</span>, <span style="color:#ae81ff">4.0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Call Stochastic Gradient Descent</span>
</span></span><span style="display:flex;"><span>final_theta <span style="color:#f92672">=</span> stochastic_gradient_descent(obj_func, gradient_func, initial_theta)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Optimal parameters:&#34;</span>, final_theta)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Minimum value of the objective function:&#34;</span>, obj_func(final_theta))
</span></span></code></pre></div><p>In this implementation, <code>obj_func</code> represents the objective function you want to minimize, and <code>gradient_func</code> computes the gradient of the loss function with respect to the model&rsquo;s parameters for a specific data point <code>i</code>. The rest of the algorithm follows the SGD procedure described earlier.</p>
<h2 id="second-order-methods">Second order Methods</h2>
<h3 id="newton-method">Newton method</h3>
<p>Newton-Raphson method, often referred to as the Newton method, is an iterative numerical technique used to find the approximate roots (or solutions) of real-valued functions. It is particularly effective for finding the roots of nonlinear equations, optimizing functions, and solving systems of nonlinear equations. The method is named after Sir Isaac Newton and Joseph Raphson, who contributed to its development.</p>
<p>The basic idea behind the Newton method is to iteratively refine an initial guess for the root by approximating the function with a linear equation (a tangent line) near the current guess. Mathematically, the algorithm can be summarized as follows:</p>
<p>Given a function $f(x)$ and an initial guess $x_0$​, repeat the following steps until a convergence criterion is met:</p>
<ol>
<li>Compute the value of the function $f(x_n)$ and its derivative $f′(x_n)$ at the current guess $x_n$​.</li>
<li>Update the guess for the root using the formula:
$(x_{n+1} = x_{n} - \frac{f&rsquo;(x_{n})}{f(x_{n})})$</li>
<li>Repeat steps 1 and 2 until $∣f(xn+1)∣$ is sufficiently close to zero or until a maximum number of iterations is reached.</li>
</ol>
<p>The method converges rapidly if the initial guess is reasonably close to the actual root and if the function is well-behaved (continuous and with a well-defined derivative).</p>
<p>Here&rsquo;s a Python implementation of the Newton method to find the root of a single-variable function:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">newton_method</span>(f, df, x0, tol<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-6</span>, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> x0
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> iteration <span style="color:#f92672">in</span> range(max_iter):
</span></span><span style="display:flex;"><span>        fx <span style="color:#f92672">=</span> f(x)
</span></span><span style="display:flex;"><span>        dfx <span style="color:#f92672">=</span> df(x)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Check for small derivatives to avoid division by zero</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> abs(dfx) <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">1e-6</span>:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">raise</span> <span style="color:#a6e22e">ValueError</span>(<span style="color:#e6db74">&#34;Derivative is too small.&#34;</span>)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        x_new <span style="color:#f92672">=</span> x <span style="color:#f92672">-</span> fx <span style="color:#f92672">/</span> dfx
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> abs(x_new <span style="color:#f92672">-</span> x) <span style="color:#f92672">&lt;</span> tol:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;Converged after </span><span style="color:#e6db74">{</span>iteration<span style="color:#e6db74">}</span><span style="color:#e6db74"> iterations.&#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> x_new
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> x_new
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">&#34;Did not converge.&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage:</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define your function f(x) and its derivative df(x)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">4</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">df</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial guess</span>
</span></span><span style="display:flex;"><span>x0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.0</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Call Newton&#39;s method</span>
</span></span><span style="display:flex;"><span>root <span style="color:#f92672">=</span> newton_method(f, df, x0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Approximate root:&#34;</span>, root)
</span></span></code></pre></div><p>In this example, <code>f(x)</code> represents the function you want to find the root of, and <code>df(x)</code> is its derivative. The algorithm iteratively refines the estimate of the root (<code>x</code>) until it converges within a specified tolerance (<code>tol</code>) or until a maximum number of iterations (<code>max_iter</code>) is reached.</p>
<h3 id="gauss-newton-method">Gauss-Newton method</h3>
<p>Gauss-Newton method iteratively updates the parameter vector ppp to minimize the objective function. In each iteration, it approximates the objective function using a linearization around the current estimate of ppp, which is why it&rsquo;s often considered an extension of the Newton-Raphson method for nonlinear optimization.</p>
<p>Here are the main steps of the Gauss-Newton method:</p>
<ol>
<li><strong>Initialization</strong> : Start with an initial guess for the parameter vector ppp.</li>
<li><strong>Iterative Update</strong>:
<ul>
<li>For each iteration:
<ul>
<li>Calculate the Jacobian matrix $J(p)$, which contains the partial derivatives of the model predictions $f_i(p)$ with respect to each parameter.</li>
<li>Calculate the residual vector $r(p)$, which is the difference between the observed data $y_i$ and the model predictions $f_i(p)$ for all data points.</li>
<li>Update the parameter vector $p$ using the following formula:
$p_{\text{new}} = p_{\text{old}} + \Delta p$
where
$\Delta p = (J^T J)^{-1} J^T r$
$J^T$ is the transpose of the Jacobian matrix, and $(J^T J)^{-1}$ is the pseudoinverse of the Jacobian matrix.</li>
<li>Repeat the iterative update until a convergence criterion is met, such as small changes in the parameter estimates or a maximum number of iterations.</li>
</ul>
</li>
</ul>
</li>
<li><strong>Convergence</strong>: The algorithm converges when the parameter estimates $p$ stabilize or when a predefined stopping criterion is satisfied.</li>
</ol>
<p>Here&rsquo;s a Python example demonstrating the Gauss-Newton method for nonlinear regression:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.optimize <span style="color:#f92672">import</span> least_squares
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the model function and its Jacobian</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">model</span>(p, x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>exp(<span style="color:#f92672">-</span>p[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">jacobian</span>(p, x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>vstack((<span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>exp(<span style="color:#f92672">-</span>p[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> x), x <span style="color:#f92672">*</span> p[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>exp(<span style="color:#f92672">-</span>p[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">*</span> x)))<span style="color:#f92672">.</span>T
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Generate synthetic data</span>
</span></span><span style="display:flex;"><span>np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>seed(<span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>x_data <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linspace(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>true_params <span style="color:#f92672">=</span> [<span style="color:#ae81ff">2.0</span>, <span style="color:#ae81ff">1.0</span>]
</span></span><span style="display:flex;"><span>y_data <span style="color:#f92672">=</span> model(true_params, x_data) <span style="color:#f92672">+</span> <span style="color:#ae81ff">0.1</span> <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randn(len(x_data))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the objective function (residuals)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">objective</span>(p):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> y_data <span style="color:#f92672">-</span> model(p, x_data)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial guess for parameters</span>
</span></span><span style="display:flex;"><span>initial_guess <span style="color:#f92672">=</span> [<span style="color:#ae81ff">1.0</span>, <span style="color:#ae81ff">2.0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use SciPy&#39;s least_squares function to perform Gauss-Newton optimization</span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> least_squares(objective, initial_guess, jac<span style="color:#f92672">=</span>jacobian, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;lm&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Extract the estimated parameters</span>
</span></span><span style="display:flex;"><span>estimated_params <span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;True parameters:&#34;</span>, true_params)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Estimated parameters:&#34;</span>, estimated_params)
</span></span></code></pre></div><p>In this example, we define a simple exponential model and generate synthetic data with added noise. Then, we use SciPy&rsquo;s <code>least_squares</code> function to perform the Gauss-Newton optimization to estimate the parameters of the model. The estimated parameters are compared to the true parameters to assess the quality of the fit.</p>
<h3 id="quasi-newton-methods">Quasi-Newton methods</h3>
<p>Quasi-Newton methods are a class of optimization algorithms used for finding the minimum of a scalar function of several variables. These methods belong to the broader category of gradient-based optimization techniques and are particularly useful when it&rsquo;s computationally expensive to compute the exact Hessian matrix (the matrix of second derivatives) of the objective function. Instead of calculating the Hessian directly, quasi-Newton methods approximate it using updates based on gradient information, making them more efficient for many practical optimization problems.</p>
<p>The most well-known quasi-Newton method is the Broyden–Fletcher–Goldfarb–Shanno (BFGS) algorithm, but there are other variants like the Limited-memory BFGS (L-BFGS) that are suitable for large-scale problems. Here&rsquo;s an overview of how quasi-Newton methods work:</p>
<ol>
<li><strong>Initialization</strong> : Start with an initial guess for the parameters (variables) you want to optimize.</li>
<li><strong>Initialization of the Approximate Hessian</strong> : Initialize an approximation of the Hessian matrix. In BFGS, for example, this is usually done with the identity matrix or a scaled version of it.</li>
<li><strong>Iterative Update</strong> : Quasi-Newton methods iteratively update the parameter vector and the approximation of the Hessian matrix until convergence is achieved. The main steps in each iteration are as follows:</li>
</ol>
<ul>
<li><strong>Calculate the Gradient</strong> : Compute the gradient of the objective function with respect to the parameters at the current parameter values.</li>
<li><strong>Solve the Quasi-Newton Equation</strong> : Quasi-Newton methods update the approximation of the Hessian matrix using information from the gradient and parameter changes. The update formula depends on the specific quasi-Newton method (e.g., BFGS or L-BFGS). The objective is to construct an approximation of the Hessian that preserves important curvature information of the objective function.</li>
<li><strong>Update Parameters</strong> : Update the parameter vector using the approximate Hessian matrix. This update step usually involves solving a linear system of equations that is determined by the approximation of the Hessian.</li>
<li><strong>Convergence Check</strong> : Check for convergence criteria, such as the magnitude of the gradient, small changes in the parameters, or a predefined number of iterations.</li>
</ul>
<ol start="4">
<li><strong>Convergence</strong> : The optimization process terminates when one or more convergence criteria are met.</li>
</ol>
<p>Quasi-Newton methods are efficient and widely used because they can handle large-scale optimization problems without explicitly computing and storing the full Hessian matrix, which can be computationally expensive and memory-intensive. Instead, they maintain an approximation of the Hessian using a limited amount of memory.</p>
<p>Here&rsquo;s an example of how to use the L-BFGS-B variant of the L-BFGS quasi-Newton method in Python using SciPy&rsquo;s optimization module:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> scipy.optimize <span style="color:#f92672">import</span> minimize
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define the objective function to minimize</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">objective_function</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> (x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> (x[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">3</span>) <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Initial guess for the parameters</span>
</span></span><span style="display:flex;"><span>initial_guess <span style="color:#f92672">=</span> [<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">0.0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Use L-BFGS-B for optimization</span>
</span></span><span style="display:flex;"><span>result <span style="color:#f92672">=</span> minimize(objective_function, initial_guess, method<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;L-BFGS-B&#39;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Extract the optimized parameters</span>
</span></span><span style="display:flex;"><span>optimized_parameters <span style="color:#f92672">=</span> result<span style="color:#f92672">.</span>x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Optimized parameters:&#34;</span>, optimized_parameters)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Minimum value of the objective function:&#34;</span>, result<span style="color:#f92672">.</span>fun)
</span></span></code></pre></div><p>In this example, we define a simple quadratic objective function to minimize, and we use the <code>minimize</code> function from SciPy&rsquo;s optimization module with the L-BFGS-B method to find the minimum. The <code>result</code> object contains the optimized parameters and the minimum value of the objective function.</p>
<h2 id="proximal-gradient-descent">Proximal Gradient Descent</h2>
<p>Proximal Gradient Descent is a method used in optimization, particularly for handling problems where the objective function is composed of two parts. The first part is convex and continious, whereas the second part is convex but not continious.</p>
<p>Implementation of Proximal Gradient Descent in Python for LASSO:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">soft_thresholding</span>(v, lambda_alpha):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>sign(v) <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>maximum(np<span style="color:#f92672">.</span>abs(v) <span style="color:#f92672">-</span> lambda_alpha, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">proximal_gradient_descent</span>(X, y, alpha, lambda_<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-3</span>, n_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    m, n <span style="color:#f92672">=</span> X<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>    beta <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Gradient step</span>
</span></span><span style="display:flex;"><span>        gradient <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>dot(X<span style="color:#f92672">.</span>T, y <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>dot(X, beta)) <span style="color:#f92672">/</span> m
</span></span><span style="display:flex;"><span>        beta <span style="color:#f92672">=</span> beta <span style="color:#f92672">-</span> lambda_ <span style="color:#f92672">*</span> gradient
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Proximal step (for L1 norm)</span>
</span></span><span style="display:flex;"><span>        beta <span style="color:#f92672">=</span> soft_thresholding(beta, lambda_ <span style="color:#f92672">*</span> alpha)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> beta
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">10</span>)  
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>beta <span style="color:#f92672">=</span> proximal_gradient_descent(X, y, alpha)
</span></span><span style="display:flex;"><span>print(beta)
</span></span></code></pre></div><h2 id="accelerated-proximal-gradient-descent">Accelerated Proximal Gradient Descent</h2>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">soft_thresholding</span>(v, lambda_alpha):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>sign(v) <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>maximum(np<span style="color:#f92672">.</span>abs(v) <span style="color:#f92672">-</span> lambda_alpha, <span style="color:#ae81ff">0</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">accelerated_proximal_gradient_descent</span>(X, y, alpha, lambda_<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-3</span>, n_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    m, n <span style="color:#f92672">=</span> X<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(n)
</span></span><span style="display:flex;"><span>    y <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>copy()
</span></span><span style="display:flex;"><span>    t <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(n_iter):
</span></span><span style="display:flex;"><span>        old_x <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>copy()
</span></span><span style="display:flex;"><span>        gradient <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>np<span style="color:#f92672">.</span>dot(X<span style="color:#f92672">.</span>T, y <span style="color:#f92672">-</span> np<span style="color:#f92672">.</span>dot(X, y)) <span style="color:#f92672">/</span> m
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> y <span style="color:#f92672">-</span> lambda_ <span style="color:#f92672">*</span> gradient
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> soft_thresholding(x, lambda_ <span style="color:#f92672">*</span> alpha)
</span></span><span style="display:flex;"><span>        t_old <span style="color:#f92672">=</span> t
</span></span><span style="display:flex;"><span>        t <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> np<span style="color:#f92672">.</span>sqrt(<span style="color:#ae81ff">1</span> <span style="color:#f92672">+</span> <span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> t <span style="color:#f92672">**</span> <span style="color:#ae81ff">2</span>)) <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>        y <span style="color:#f92672">=</span> x <span style="color:#f92672">+</span> ((t_old <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>) <span style="color:#f92672">/</span> t) <span style="color:#f92672">*</span> (x <span style="color:#f92672">-</span> old_x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>X <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">10</span>) 
</span></span><span style="display:flex;"><span>y <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>alpha <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.1</span>  
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>beta <span style="color:#f92672">=</span> accelerated_proximal_gradient_descent(X, y, alpha)
</span></span><span style="display:flex;"><span>print(beta)
</span></span></code></pre></div><h2 id="augmented-lagrangian-method-and-alternating-direction-methods-for-multipliers">Augmented Lagrangian Method and Alternating Direction Methods for Multipliers</h2>
<ul>
<li>Proximal gradient descent is useful for minimizing decomposable convex functions with a differentiable and a non-differentiable part</li>
<li>However if prox is not easy to obtain, proximal gradient methods may not be useful.</li>
<li>Augmented Lagrangian Method and Alternating Direction Methods for Multipliers can be useful here</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Objective function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">f</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x[<span style="color:#ae81ff">0</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span> <span style="color:#f92672">+</span> x[<span style="color:#ae81ff">1</span>]<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Constraint (should return zero when constraint is satisfied)</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">h</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x[<span style="color:#ae81ff">0</span>] <span style="color:#f92672">+</span> x[<span style="color:#ae81ff">1</span>] <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Gradient of the objective function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">grad_f</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">*</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Gradient of the constraint function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">grad_h</span>(x):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Augmented Lagrangian function</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">L_A</span>(x, lambda_, rho):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> f(x) <span style="color:#f92672">+</span> lambda_ <span style="color:#f92672">*</span> h(x) <span style="color:#f92672">+</span> (rho <span style="color:#f92672">/</span> <span style="color:#ae81ff">2</span>) <span style="color:#f92672">*</span> h(x)<span style="color:#f92672">**</span><span style="color:#ae81ff">2</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Gradient of the Augmented Lagrangian</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">grad_L_A</span>(x, lambda_, rho):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> grad_f(x) <span style="color:#f92672">+</span> lambda_ <span style="color:#f92672">*</span> grad_h(x) <span style="color:#f92672">+</span> rho <span style="color:#f92672">*</span> h(x) <span style="color:#f92672">*</span> grad_h(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Simple Gradient Descent for the x-update step</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">gradient_descent_update</span>(x, lambda_, rho, learning_rate<span style="color:#f92672">=</span><span style="color:#ae81ff">0.01</span>):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x <span style="color:#f92672">-</span> learning_rate <span style="color:#f92672">*</span> grad_L_A(x, lambda_, rho)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Augmented Lagrangian Method</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">augmented_lagrangian_method</span>(initial_x, initial_lambda, rho, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> initial_x
</span></span><span style="display:flex;"><span>    lambda_ <span style="color:#f92672">=</span> initial_lambda
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(max_iter):
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> gradient_descent_update(x, lambda_, rho)
</span></span><span style="display:flex;"><span>        lambda_ <span style="color:#f92672">=</span> lambda_ <span style="color:#f92672">+</span> rho <span style="color:#f92672">*</span> h(x)  <span style="color:#75715e"># λ-update</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage</span>
</span></span><span style="display:flex;"><span>x_opt <span style="color:#f92672">=</span> augmented_lagrangian_method(np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">0</span>]), <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;Optimized x:&#34;</span>, x_opt)
</span></span></code></pre></div><h3 id="admm">ADMM</h3>
<ul>
<li>Similar to Augmented Lagrangian method, we augment the objective function.</li>
<li>The augmented term does not change the objective, as its value is always zero due to the constraints.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">admm</span>(f, g, A, B, c, rho, max_iter<span style="color:#f92672">=</span><span style="color:#ae81ff">100</span>):
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(A<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    z <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(B<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>])
</span></span><span style="display:flex;"><span>    lambda_ <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(c<span style="color:#f92672">.</span>shape)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(max_iter):
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># x-update (modify according to your f)</span>
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(A<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> A <span style="color:#f92672">+</span> rho <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>eye(A<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>])) <span style="color:#f92672">@</span> (A<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> (c <span style="color:#f92672">-</span> B <span style="color:#f92672">@</span> z <span style="color:#f92672">+</span> lambda_<span style="color:#f92672">/</span>rho))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># z-update (modify according to your g)</span>
</span></span><span style="display:flex;"><span>        z <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>inv(B<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> B <span style="color:#f92672">+</span> rho <span style="color:#f92672">*</span> np<span style="color:#f92672">.</span>eye(B<span style="color:#f92672">.</span>shape[<span style="color:#ae81ff">1</span>])) <span style="color:#f92672">@</span> (B<span style="color:#f92672">.</span>T <span style="color:#f92672">@</span> (c <span style="color:#f92672">-</span> A <span style="color:#f92672">@</span> x <span style="color:#f92672">-</span> lambda_<span style="color:#f92672">/</span>rho))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># λ-update</span>
</span></span><span style="display:flex;"><span>        lambda_ <span style="color:#f92672">=</span> lambda_ <span style="color:#f92672">+</span> rho <span style="color:#f92672">*</span> (A <span style="color:#f92672">@</span> x <span style="color:#f92672">+</span> B <span style="color:#f92672">@</span> z <span style="color:#f92672">-</span> c)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x, z
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage</span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>], [<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]])
</span></span><span style="display:flex;"><span>B <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([[<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">1</span>], [<span style="color:#ae81ff">2</span>, <span style="color:#f92672">-</span><span style="color:#ae81ff">2</span>]])
</span></span><span style="display:flex;"><span>c <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array([<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>])
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Define f and g (here they are simple placeholders)</span>
</span></span><span style="display:flex;"><span>f <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> x: np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(x, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>g <span style="color:#f92672">=</span> <span style="color:#66d9ef">lambda</span> z: np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(z, <span style="color:#ae81ff">2</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>rho <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>
</span></span><span style="display:flex;"><span>x, z <span style="color:#f92672">=</span> admm(f, g, A, B, c, rho)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;x:&#34;</span>, x)
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#34;z:&#34;</span>, z)
</span></span></code></pre></div><h2 id="coordinate-descent-algorithm">Coordinate Descent Algorithm</h2>
<p>Coordinate Descent is an optimization algorithm where the solution is obtained by successively optimizing the objective function along one direction or coordinate at a time. This approach is particularly effective for problems where each step of optimizing along a single coordinate (or a small block of coordinates) can be performed efficiently. Coordinate Descent is widely used in scenarios such as large-scale linear regression, LASSO regression, and machine learning algorithms where the dimensionality of the data is high.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">coordinate_descent</span>(A, b, lam, num_iters<span style="color:#f92672">=</span><span style="color:#ae81ff">1000</span>, tol<span style="color:#f92672">=</span><span style="color:#ae81ff">1e-5</span>):
</span></span><span style="display:flex;"><span>    m, n <span style="color:#f92672">=</span> A<span style="color:#f92672">.</span>shape
</span></span><span style="display:flex;"><span>    x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>zeros(n)
</span></span><span style="display:flex;"><span>    r <span style="color:#f92672">=</span> b <span style="color:#f92672">-</span> A<span style="color:#f92672">.</span>dot(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(num_iters):
</span></span><span style="display:flex;"><span>        x_old <span style="color:#f92672">=</span> x<span style="color:#f92672">.</span>copy()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(n):
</span></span><span style="display:flex;"><span>            <span style="color:#75715e"># Compute the update for coordinate i (assuming a quadratic objective)</span>
</span></span><span style="display:flex;"><span>            A_i <span style="color:#f92672">=</span> A[:, i]
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">+=</span> A_i <span style="color:#f92672">*</span> x[i]
</span></span><span style="display:flex;"><span>            x[i] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>dot(A_i, r) <span style="color:#f92672">/</span> (np<span style="color:#f92672">.</span>dot(A_i, A_i) <span style="color:#f92672">+</span> lam)
</span></span><span style="display:flex;"><span>            r <span style="color:#f92672">-=</span> A_i <span style="color:#f92672">*</span> x[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e"># Check for convergence</span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> np<span style="color:#f92672">.</span>linalg<span style="color:#f92672">.</span>norm(x <span style="color:#f92672">-</span> x_old, ord<span style="color:#f92672">=</span><span style="color:#ae81ff">2</span>) <span style="color:#f92672">&lt;</span> tol:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Example usage</span>
</span></span><span style="display:flex;"><span>A <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">10</span>)
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>rand(<span style="color:#ae81ff">100</span>)
</span></span><span style="display:flex;"><span>lam <span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span>  <span style="color:#75715e"># Regularization parameter</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>x <span style="color:#f92672">=</span> coordinate_descent(A, b, lam)
</span></span><span style="display:flex;"><span>print(x)
</span></span></code></pre></div><h1 id="regularization">Regularization</h1>
<p>Regularization is a crucial technique in machine learning used to prevent overfitting and improve the generalization ability of a model. Overfitting occurs when a model learns the training data too well, including its noise and outliers, leading to poor performance on new, unseen data. Regularization helps to keep the model simple and more generalized by adding a penalty on the complexity of the model. The most common regularization techniques are:</p>
<ol>
<li><strong>L1 Regularization (Lasso Regression):</strong>  Adds a penalty equal to the absolute value of the magnitude of coefficients. This can lead to coefficients being zero, which is useful for feature selection in models where some features are irrelevant or redundant. L1 regularization tends to produce sparse solutions and is defined as:</li>
</ol>
<p>Cost function+λ∑∣wi∣\text{Cost function} + \lambda \sum |w_i|Cost function+λ∑∣wi​∣</p>
<p>Where λ\lambdaλ is a regularization parameter and wiw_iwi​ are the model weights.
2. <strong>L2 Regularization (Ridge Regression):</strong>  Adds a penalty equal to the square of the magnitude of coefficients. This discourages large weights but does not force them to be zero, leading to a model where all features are considered but their impact is moderated. L2 regularization is defined as:</p>
<p>Cost function+λ∑wi2\text{Cost function} + \lambda \sum w_i^2Cost function+λ∑wi2​</p>
<p>This method tends to distribute error among all the terms, but it doesn’t necessarily eliminate any weights completely, as L1 can.
3. <strong>Elastic Net:</strong>  A combination of L1 and L2 regularization. It adds both penalties to the model and is useful when there are multiple features that are correlated with one another. Elastic Net aims to enjoy the benefits of both Ridge and Lasso regularization, allowing it to handle situations when there are numerous correlated features.
4. <strong>Early Stopping:</strong>  A form of regularization used especially in neural networks where training is stopped as soon as the performance on a validation set starts to degrade. This prevents the model from learning the training data too well.
5. <strong>Dropout:</strong>  Specifically used in neural networks, it involves randomly setting a fraction of input units to 0 at each update during training time, which helps prevent overfitting. This forces the network to not rely too much on any one node, hence aiding in generalization.
6. <strong>Max-Norm Regularization:</strong>  In neural networks, this involves limiting the size of the weight vector for every neuron to a maximum value. This can be effective at preventing overfitting and is often used alongside dropout.</p>
<h2 id="ridge-regression-l_2">Ridge Regression ($L_2$)</h2>
<p>Ridge regression is a technique used primarily to analyze multiple regression data that suffer from multicollinearity. When multicollinearity occurs, least squares estimates are unbiased, but their variances are large so they may be far from the true value. This can result in overfitting in the model, where the model performs well on the training data but poorly on unseen data.</p>
<p><strong>Key Concepts in Ridge Regression:</strong></p>
<ol>
<li><strong>Shrinkage Penalty:</strong>  The core idea of ridge regression is to introduce a regularization (shrinkage penalty) to the regression estimates. This method is also known as Tikhonov regularization. It works by penalizing the size of the regression coefficients.</li>
<li><strong>Cost Function:</strong>  In ridge regression, the cost function is altered by adding a penalty equivalent to square of the magnitude of the coefficients. The regularization term is given by $λ$ (lambda), a tuning parameter multiplied by the sum of the squares of the coefficients:</li>
</ol>
<p>$J(\theta) = \text{RSS} + \lambda \sum_{j=1}^{p} \theta_j^2$</p>
<p>Here, RSS is the residual sum of squares and $\theta$ represents the coefficient vector. The λ controls the amount of shrinkage: the larger the value of λ, the greater the amount of shrinkage.</p>
<ol start="3">
<li><strong>Bias-Variance Trade-off:</strong>  By introducing $λ$, ridge regression trades off the unbiasedness of the OLS estimator for a reduction in variance, potentially leading to better mean squared error (MSE) on new observations. The coefficients are shrunk towards zero and towards each other, leading to a more stable and interpretable model.</li>
<li><strong>Solving Ridge Regression:</strong>  The solution for the ridge estimate is:</li>
</ol>
<p>$\hat{\beta}^{ridge} = (X^TX + \lambda I)^{-1}X^Ty$</p>
<p>where XXX is the matrix of input features, and III is the identity matrix. This formula shows how ridge regression penalizes the scale of the coefficients based on the value of λ.</p>
<ol start="5">
<li>
<p><strong>Choice of λ:</strong>  The value of λ is crucial in ridge regression. If λ = 0, the solution is just the ordinary least squares estimates. As λ → ∞, all coefficients are shrunk towards zero. The choice of λ is typically done via cross-validation, often seeking to minimize prediction error.</p>
</li>
<li>
<p><strong>Geometric Interpretation:</strong>  Geometrically, ridge regression constrains the coefficients to lie within a sphere centered at zero with radius proportional to 1/λ1/\sqrt{\lambda}1/λ​. This constraint can lead to better prediction accuracy when the true relationship between the target and the predictors is approximately linear but complex, with predictors exhibiting collinearity.</p>
</li>
<li>
<p><strong>Multicollinearity:</strong>  Ridge regression doesn&rsquo;t eliminate multicollinearity but mitigates its problematic aspects by controlling the coefficient magnitude and introducing bias into the estimates, which may improve prediction accuracy.</p>
</li>
<li>
<p><strong>Applications:</strong>  Ridge regression is widely used when the data has many multicollinear predictors and when prediction accuracy is a priority over interpretability. It&rsquo;s also used in scenarios where the number of predictors exceeds the number of observations.</p>
</li>
</ol>
<h3 id="statistics-form">Statistics Form</h3>
<p>$\min_{\beta} \sum_{i=1}^{n} (y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij})^2 + \lambda \sum_{j=1}^{p} \beta_j^2$</p>
<h3 id="optimization-form">Optimization Form</h3>
<p>$\min_{\beta} { | \mathbf{y} - \mathbf{X}\beta |^2 + \lambda | \beta |^2 }$</p>
<h3 id="matrix-form">Matrix Form</h3>
<p>$| \mathbf{y} - \mathbf{X}\beta |^2 + \lambda | \beta |^2$
$\mathbf{X}^\top \mathbf{X}\beta + \lambda \mathbf{I}\beta = \mathbf{X}^\top \mathbf{y}$
$\beta = (\mathbf{X}^\top \mathbf{X} + \lambda \mathbf{I})^{-1} \mathbf{X}^\top \mathbf{y}$</p>
<h2 id="lasso-regression">Lasso Regression</h2>
<p>The key aspects of Lasso regression include:</p>
<ol>
<li><strong>Regularization Term:</strong>  Lasso regression modifies the cost function by adding a penalty equivalent to the absolute value of the magnitude of coefficients. This can be represented as:
$J(\theta) = \text{RSS} + \lambda \sum_{j=1}^{p} |\theta_j|$</li>
</ol>
<p>Here, RSS is the residual sum of squares, θj\theta_jθj​ are the coefficients, and λ\lambdaλ is a tuning parameter controlling the strength of the penalty.</p>
<ol start="2">
<li>
<p><strong>Objective and Impact:</strong>  Unlike Ridge regression, which aims to minimize the square of the coefficients, Lasso regression tends to produce some coefficients that are exactly zero and others that are shrunk towards zero but potentially non-zero. This property of Lasso regression helps in feature selection along with regularization, making it particularly useful in cases where we suspect that many features could be irrelevant or redundant.</p>
</li>
<li>
<p><strong>Bias-Variance Trade-Off:</strong>  Similar to Ridge regression, Lasso trades off bias for variance. By increasing λ, more coefficients are set to zero, which increases model bias but can decrease variance, potentially leading to better generalization.</p>
</li>
<li>
<p><strong>Solving Lasso Regression:</strong>  The Lasso problem does not have a closed-form solution like Ridge regression because the absolute value function is not differentiable at zero. Instead, it&rsquo;s typically solved using numerical techniques like coordinate descent.</p>
</li>
<li>
<p><strong>Choice of λ:</strong>  The selection of the tuning parameter λ is crucial. When λ = 0, the Lasso estimates equal the least squares estimates. As λ increases, the impact of the shrinkage penalty grows. For large values of λ, many coefficients are exactly zeroed.</p>
</li>
<li>
<p><strong>Sparse Models:</strong>  Due to its tendency to prefer solutions with fewer parameter values, Lasso is particularly useful in creating sparse models in high-dimensional data where feature selection is essential.</p>
</li>
<li>
<p><strong>Applications and Limitations:</strong>  Lasso is widely used in fields like bioinformatics, image analysis, and genomics where feature selection is as crucial as prediction. One of the limitations of Lasso is that if the number of predictors is greater than the number of observations, Lasso selects at most n predictors as non-zero, even if all predictors are relevant (or &ldquo;true&rdquo;).</p>
</li>
</ol>
<h3 id="statistics-form-1">Statistics Form</h3>
<p>$\min_{\beta} \sum_{i=1}^{n} (y_i - \beta_0 - \sum_{j=1}^{p} \beta_j x_{ij})^2 + \lambda \sum_{j=1}^{p} |\beta_j|$</p>
<h3 id="optimization-form-1">Optimization Form</h3>
<p>$\min_{\beta} { | \mathbf{y} - \mathbf{X}\beta |^2 + \lambda \sum_{j=1}^{p} |\beta_j| }$</p>
<h3 id="matrix-form-1">Matrix Form</h3>
<p>In Lasso regression, there isn&rsquo;t a closed-form solution like there is for Ridge Regression due to the absolute value operation in the regularization term. This makes it challenging to express Lasso regression in a simple matrix form. The non-differentiability of the absolute value at zero means that solutions have to be found via numerical methods like coordinate descent, rather than a straightforward analytical solution.</p>
<h2 id="nng-and-adaptive-lasso">NNG and Adaptive Lasso</h2>
<h3 id="nng">NNG</h3>
<p>The Non-Negative Garrote, introduced by Breiman in 1995, is a method for variable selection and shrinkage in linear models. It&rsquo;s closely related to, but distinct from, techniques like Ridge and Lasso regression.</p>
<p><strong>Key Aspects:</strong></p>
<ol>
<li><strong>Formulation:</strong>
The NNG modifies the ordinary least squares (OLS) estimates by applying a non-negative shrinkage factor.</li>
</ol>
<p>Here, vjv_jvj​ are non-negative constants, λ\lambdaλ is a non-negative tuning parameter, and (x)+=max⁡(0,x)(x)_+ = \max(0, x)(x)+​=max(0,x). This approach effectively shrinks the OLS estimates towards zero, with the possibility of setting some coefficients exactly to zero.</p>
<ol start="2">
<li>
<p><strong>Weights:</strong>
The constants vjv_jvj​ are crucial in determining how much each coefficient is shrunk. Different methods for choosing vjv_jvj​ include setting them to be proportional to the inverse of the absolute values of the β^OLS\hat{\beta}^{OLS}β^​OLS or their squares.</p>
</li>
<li>
<p><strong>Characteristics:</strong>
Unlike Lasso, NNG does not directly impose sparsity by constraining the size of coefficients. Instead, it adapts the shrinkage of each coefficient based on the OLS estimates, which can sometimes lead to better prediction accuracy and interpretability, especially when the OLS estimates are believed to be good approximations.</p>
</li>
</ol>
<h3 id="adaptive-lasso">Adaptive Lasso</h3>
<p>The Adaptive Lasso is a variant of the traditional Lasso method, designed to enjoy the consistency properties that the standard Lasso may lack, particularly in terms of variable selection.</p>
<p><strong>Key Aspects:</strong></p>
<ol>
<li><strong>Formulation:</strong>
The Adaptive Lasso modifies the Lasso penalty by weighting the absolute values of the coefficients. The cost function becomes:</li>
</ol>
<p>$J(\theta) = \text{RSS} + \lambda \sum_{j=1}^{p} w_j |\theta_j|$</p>
<p>Here, wjw_jwj​ are weights applied to each coefficient.</p>
<ol start="2">
<li>
<p><strong>Weights:</strong>
A common choice for weights is the inverse of the absolute values of the coefficients from an OLS estimate or a Ridge regression estimate, i.e., wj=1/∣β^jOLS∣w_j = 1 / |\hat{\beta}_j^{OLS}|wj​=1/∣β^​jOLS​∣. This choice of weights allows for larger penalties on coefficients that were small in the OLS model, promoting sparsity.</p>
</li>
<li>
<p><strong>Properties:</strong>
The Adaptive Lasso is particularly known for its oracle properties. An estimator is said to possess the oracle property if it can correctly select the true model asymptotically — it identifies zero coefficients correctly as zero and provides consistent estimates for the non-zero coefficients.</p>
</li>
</ol>
<p>$\min_{\beta} \sum_{i=1}^{n} (y_i - \sum_{j=1}^{p} \beta_j x_{ij})^2 + \lambda \sum_{j=1}^{p} w_j |\beta_j|$</p>
<h2 id="elastic-net">Elastic Net</h2>
<p>Elastic Net regression is a regularization and variable selection method that linearly combines the penalties of the Lasso and Ridge methods. It&rsquo;s particularly useful in the context of models with highly correlated predictors or when the number of predictors ppp is greater than the number of observations nnn. Here are some key points that are crucial in understanding Elastic Net.</p>
<h3 id="key-characteristics">Key Characteristics</h3>
<ol>
<li><strong>Penalty Term:</strong>
Elastic Net adds both the L1 and L2 norm of the coefficients as penalty terms to the loss function:</li>
</ol>
<p>$J(\theta) = \text{RSS} + \lambda \left( \alpha \sum_{j=1}^{p} |\theta_j| + \frac{1 - \alpha}{2} \sum_{j=1}^{p} \theta_j^2 \right)$</p>
<p>Here, RSS is the residual sum of squares, θj\theta_jθj​ represents the regression coefficients, λ\lambdaλ is the tuning parameter that controls the overall strength of the penalty, and α\alphaα is the balance between L1 and L2 penalty (with α=1\alpha = 1α=1 being the Lasso penalty, and α=0\alpha = 0α=0 the Ridge penalty).</p>
<ol start="2">
<li><strong>Overcoming Limitations of Lasso and Ridge:</strong></li>
</ol>
<ul>
<li><strong>Lasso&rsquo;s Limitation:</strong>  Lasso can only select at most nnn variables before it saturates when p&gt;np &gt; np&gt;n. Also, in the case of highly correlated variables, Lasso tends to arbitrarily select any one variable among the correlated ones.</li>
<li><strong>Ridge&rsquo;s Limitation:</strong>  Ridge regression can shrink the coefficients towards zero but cannot set them exactly to zero (no feature selection).</li>
</ul>
<p>Elastic Net aims to overcome these limitations by combining the penalties. It can select groups of correlated variables, unlike Lasso which might just pick one from a group.</p>
<ol start="3">
<li>
<p><strong>Variable Selection and Grouping Effect:</strong>
The Elastic Net, due to its L1 penalty component, has a variable selection feature. The L2 penalty encourages grouping effect where strongly correlated predictors tend to be in or out of the model together.</p>
</li>
<li>
<p><strong>Tuning Parameters:</strong>
The choice of λ\lambdaλ and α\alphaα is crucial:</p>
</li>
</ol>
<ul>
<li>λ\lambdaλ controls the overall strength of the penalty, often chosen via cross-validation.</li>
<li>α\alphaα decides the mix of the L1 and L2 penalties, also typically selected through cross-validation.</li>
</ul>
<ol start="5">
<li><strong>Computational Aspects:</strong>
The presence of the L1 penalty means that, like Lasso, Elastic Net doesn&rsquo;t have a closed-form solution and is usually solved using coordinate gradient descent methods.</li>
</ol>
<h3 id="applications">Applications</h3>
<p>Elastic Net is particularly useful in genomic data and other high-dimensional datasets where the number of predictors can be much larger than the number of observations. Its ability to handle multicollinearity and select a relevant subset of variables makes it a powerful tool in both predictive modeling and feature selection.</p>
<p>Understanding and implementing Elastic Net requires a grasp of both Lasso and Ridge regression&rsquo;s strengths and weaknesses. Elastic Net stands out in scenarios where you need a middle ground between feature elimination (Lasso) and feature shrinkage (Ridge), especially when dealing with correlated features or when the dimensionality is high compared to the sample size.</p>
<p>$\min_{\beta} \sum_{i=1}^{n} (y_i - \sum_{j=1}^{p} \beta_j x_{ij})^2 + \lambda_1 \sum_{j=1}^{p} |\beta_j| + \lambda_2 \sum_{j=1}^{p} \beta_j^2$</p>
<h2 id="group-lasso">Group Lasso</h2>
<p>Group Lasso is an extension of the Lasso (Least Absolute Shrinkage and Selection Operator) technique, tailored for situations where predictors (features) can be naturally divided into groups, and we are interested in selecting or discarding these groups as units. It&rsquo;s particularly useful in models where some variables are categorical and have been one-hot encoded, leading to groups of dummy variables in the dataset, or in situations with a hierarchical or grouped structure in the predictors.</p>
<h3 id="key-concepts">Key Concepts:</h3>
<ol>
<li><strong>Formulation:</strong>
In Group Lasso, the regularization term is modified to sum over groups of coefficients, rather than individual coefficients as in standard Lasso. The optimization problem is typically formulated as:</li>
</ol>
<p>$\min_{\theta} \frac{1}{2n} | Y - X\theta |^2_2 + \lambda \sum_{g=1}^{G} \sqrt{p_g} | \theta_g |
$</p>
<p>Here, θ\thetaθ represents the vector of coefficients, split into GGG groups. θg\theta_gθg​ denotes the subset of coefficients belonging to group ggg, pgp_gpg​ is the size of group ggg, λ\lambdaλ is a non-negative regularization parameter, and ∥⋅∥| \cdot |∥⋅∥ denotes the Euclidean norm.</p>
<ol start="2">
<li>
<p><strong>Group-wise Sparsity:</strong>
The key feature of Group Lasso is its ability to enforce group-wise sparsity. That is, if the coefficients of a particular group are collectively not significant, Group Lasso can shrink all of these coefficients to zero simultaneously, effectively removing the entire group of features from the model.</p>
</li>
<li>
<p><strong>Normalization by Group Size:</strong>
The pg\sqrt{p_g}pg​​ term normalizes the penalty by group size, ensuring that larger groups don&rsquo;t dominate the penalty term purely by virtue of having more coefficients.</p>
</li>
<li>
<p><strong>Applications:</strong>
Group Lasso finds applications in multiple fields, including bioinformatics, signal processing, and any domain where variables can be naturally grouped. It&rsquo;s especially useful in models with hierarchical feature organization or when dealing with categorical variables that have been transformed into multiple dummy variables.</p>
</li>
</ol>
<h3 id="computational-aspects-and-challenges">Computational Aspects and Challenges:</h3>
<ul>
<li><strong>Optimization:</strong>  Solving the Group Lasso problem requires specialized optimization algorithms. Coordinate descent methods, similar to those used in standard Lasso, are often adapted for Group Lasso.</li>
<li><strong>Tuning:</strong>  Selecting the regularization parameter λ\lambdaλ is crucial and can be challenging. It&rsquo;s typically done using cross-validation or similar techniques.</li>
<li><strong>Interpretability:</strong>  While Group Lasso provides a clear mechanism for feature selection at the group level, interpreting the results, particularly in the context of the relationships within and between groups, can be complex.</li>
</ul>
<p>Group Lasso extends the concept of sparsity from individual predictors to groups of predictors, providing a powerful tool for models where group structure is important. Its usage demands a clear understanding of group relevance in the predictive model and careful tuning and validation of the model.</p>
<p>$\min_{\beta} \sum_{i=1}^{n} (y_i - \sum_{j=1}^{p} \beta_j x_{ij})^2 + \lambda \sum_{g=1}^{G} \sqrt{m_g} |\beta_{g}|_2$</p>
</div>
	</section>

</article>

		</main>
		<aside role="contentinfo"
			class="w-full md:w-2/5 xl:w-1/2 md:pr-12 lg:pr-20 xl:pr-24 order-4 md:order-3 md:sticky md:bottom-0 self-end max-w-2xl">
			<div class="md:float-right md:text-right leading-loose tracking-tight md:mb-2">
				
	<div class="md:max-w-xs  flex flex-col md:items-end">
	<ul class="font-serif flex-grow-0 flex justify-between flex-wrap md:flex-col">
	
	
	<li class="px-1 md:px-0">
		<a href="/posts/" title="Posts page" 
			class="font-medium text-medium-red-violet-600 hover:text-medium-red-violet-400" >
			Posts
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/resume/" title="Resume page" >
			Resume
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/certifications/" title="Certifications page" >
			Certifications
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/publications/" title="Publications page" >
			Publications
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/tags/" title="Tags page" >
			Tags
		</a>
	</li>
	
	<li class="px-1 md:px-0">
		<a href="/categories/" title="Categories page" >
			Categories
		</a>
	</li>
	
	
	
	
	<div id="fastSearch" class="m-0">
		<input id="searchInput" type="text" size=10 
			class="bg-gray-100 focus:outline-none border-b border-gray-100 focus:border-eucalyptus-300 md:text-right
			placeholder-java-500 min-w-0 max-w-xxxs"
			placeholder="search" />
		<ul id="searchResults" class="bg-gray-200 px-2 divide-y divide-gray-400">
		</ul>
	</div>
	
</ul>
	

<div class="flex flex-wrap-reverse md:justify-end content-end md:content-start justify-start items-start md:flex-col  max-h-16">
	
	<a href='https://github.com/ayushsubedi' target="_blank" class="github icon pl-1 text-eucalyptus-400 hover:text-java-400" title="github link" rel="noopener"
		aria-label="follow on github——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path fill-rule="nonzero" d="M5.883 18.653c-.3-.2-.558-.455-.86-.816a50.32 50.32 0 0 1-.466-.579c-.463-.575-.755-.84-1.057-.949a1 1 0 0 1 .676-1.883c.752.27 1.261.735 1.947 1.588-.094-.117.34.427.433.539.19.227.33.365.44.438.204.137.587.196 1.15.14.023-.382.094-.753.202-1.095C5.38 15.31 3.7 13.396 3.7 9.64c0-1.24.37-2.356 1.058-3.292-.218-.894-.185-1.975.302-3.192a1 1 0 0 1 .63-.582c.081-.024.127-.035.208-.047.803-.123 1.937.17 3.415 1.096A11.731 11.731 0 0 1 12 3.315c.912 0 1.818.104 2.684.308 1.477-.933 2.613-1.226 3.422-1.096.085.013.157.03.218.05a1 1 0 0 1 .616.58c.487 1.216.52 2.297.302 3.19.691.936 1.058 2.045 1.058 3.293 0 3.757-1.674 5.665-4.642 6.392.125.415.19.879.19 1.38a300.492 300.492 0 0 1-.012 2.716 1 1 0 0 1-.019 1.958c-1.139.228-1.983-.532-1.983-1.525l.002-.446.005-.705c.005-.708.007-1.338.007-1.998 0-.697-.183-1.152-.425-1.36-.661-.57-.326-1.655.54-1.752 2.967-.333 4.337-1.482 4.337-4.66 0-.955-.312-1.744-.913-2.404a1 1 0 0 1-.19-1.045c.166-.414.237-.957.096-1.614l-.01.003c-.491.139-1.11.44-1.858.949a1 1 0 0 1-.833.135A9.626 9.626 0 0 0 12 5.315c-.89 0-1.772.119-2.592.35a1 1 0 0 1-.83-.134c-.752-.507-1.374-.807-1.868-.947-.144.653-.073 1.194.092 1.607a1 1 0 0 1-.189 1.045C6.016 7.89 5.7 8.694 5.7 9.64c0 3.172 1.371 4.328 4.322 4.66.865.097 1.201 1.177.544 1.748-.192.168-.429.732-.429 1.364v3.15c0 .986-.835 1.725-1.96 1.528a1 1 0 0 1-.04-1.962v-.99c-.91.061-1.662-.088-2.254-.485z"/>
    </g>
</svg>

		</div>
	</a>
	
	<a href='https://www.instagram.com/ayushsube/' target="_blank" class="instagram icon pl-1 text-eucalyptus-400 hover:text-java-400" title="instagram link" rel="noopener"
		aria-label="follow on instagram——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path fill-rule="nonzero" d="M12 9a3 3 0 1 0 0 6 3 3 0 0 0 0-6zm0-2a5 5 0 1 1 0 10 5 5 0 0 1 0-10zm6.5-.25a1.25 1.25 0 0 1-2.5 0 1.25 1.25 0 0 1 2.5 0zM12 4c-2.474 0-2.878.007-4.029.058-.784.037-1.31.142-1.798.332-.434.168-.747.369-1.08.703a2.89 2.89 0 0 0-.704 1.08c-.19.49-.295 1.015-.331 1.798C4.006 9.075 4 9.461 4 12c0 2.474.007 2.878.058 4.029.037.783.142 1.31.331 1.797.17.435.37.748.702 1.08.337.336.65.537 1.08.703.494.191 1.02.297 1.8.333C9.075 19.994 9.461 20 12 20c2.474 0 2.878-.007 4.029-.058.782-.037 1.309-.142 1.797-.331.433-.169.748-.37 1.08-.702.337-.337.538-.65.704-1.08.19-.493.296-1.02.332-1.8.052-1.104.058-1.49.058-4.029 0-2.474-.007-2.878-.058-4.029-.037-.782-.142-1.31-.332-1.798a2.911 2.911 0 0 0-.703-1.08 2.884 2.884 0 0 0-1.08-.704c-.49-.19-1.016-.295-1.798-.331C14.925 4.006 14.539 4 12 4zm0-2c2.717 0 3.056.01 4.122.06 1.065.05 1.79.217 2.428.465.66.254 1.216.598 1.772 1.153a4.908 4.908 0 0 1 1.153 1.772c.247.637.415 1.363.465 2.428.047 1.066.06 1.405.06 4.122 0 2.717-.01 3.056-.06 4.122-.05 1.065-.218 1.79-.465 2.428a4.883 4.883 0 0 1-1.153 1.772 4.915 4.915 0 0 1-1.772 1.153c-.637.247-1.363.415-2.428.465-1.066.047-1.405.06-4.122.06-2.717 0-3.056-.01-4.122-.06-1.065-.05-1.79-.218-2.428-.465a4.89 4.89 0 0 1-1.772-1.153 4.904 4.904 0 0 1-1.153-1.772c-.248-.637-.415-1.363-.465-2.428C2.013 15.056 2 14.717 2 12c0-2.717.01-3.056.06-4.122.05-1.066.217-1.79.465-2.428a4.88 4.88 0 0 1 1.153-1.772A4.897 4.897 0 0 1 5.45 2.525c.638-.248 1.362-.415 2.428-.465C8.944 2.013 9.283 2 12 2z"/>
    </g>
</svg>

		</div>
	</a>
	
	<a href='https://www.linkedin.com/in/ayush-subedi/' target="_blank" class="linkedin icon pl-1 text-eucalyptus-400 hover:text-java-400" title="linkedin link" rel="noopener"
		aria-label="follow on linkedin——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path d="M12 9.55C12.917 8.613 14.111 8 15.5 8a5.5 5.5 0 0 1 5.5 5.5V21h-2v-7.5a3.5 3.5 0 0 0-7 0V21h-2V8.5h2v1.05zM5 6.5a1.5 1.5 0 1 1 0-3 1.5 1.5 0 0 1 0 3zm-1 2h2V21H4V8.5z"/>
    </g>
</svg>

		</div>
	</a>
	
	<a href='mailto:ayush.subedi@gmail.com' target="_blank" class="mail icon pl-1 text-eucalyptus-400 hover:text-java-400" title="mail link" rel="noopener"
		aria-label="follow on mail——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path d="M3 3h18a1 1 0 0 1 1 1v16a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4a1 1 0 0 1 1-1zm17 4.238l-7.928 7.1L4 7.216V19h16V7.238zM4.511 5l7.55 6.662L19.502 5H4.511z"/>
    </g>
</svg>
		</div>
	</a>
	
	<a href='https://public.tableau.com/app/profile/ayush3339' target="_blank" class="tableau icon pl-1 text-eucalyptus-400 hover:text-java-400" title="tableau link" rel="noopener"
		aria-label="follow on tableau——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M2 13H8V21H2V13ZM9 3H15V21H9V3ZM16 8H22V21H16V8Z"/></svg>
		</div>
	</a>
	
	<a href='https://twitter.com/ayushsubs' target="_blank" class="twitter icon pl-1 text-eucalyptus-400 hover:text-java-400" title="twitter link" rel="noopener"
		aria-label="follow on twitter——Opens in a new window">
		
		<div class="fill-current h-8 w-8">
			<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
    <g>
        <path fill="none" d="M0 0h24v24H0z"/>
        <path fill-rule="nonzero" d="M15.3 5.55a2.9 2.9 0 0 0-2.9 2.847l-.028 1.575a.6.6 0 0 1-.68.583l-1.561-.212c-2.054-.28-4.022-1.226-5.91-2.799-.598 3.31.57 5.603 3.383 7.372l1.747 1.098a.6.6 0 0 1 .034.993L7.793 18.17c.947.059 1.846.017 2.592-.131 4.718-.942 7.855-4.492 7.855-10.348 0-.478-1.012-2.141-2.94-2.141zm-4.9 2.81a4.9 4.9 0 0 1 8.385-3.355c.711-.005 1.316.175 2.669-.645-.335 1.64-.5 2.352-1.214 3.331 0 7.642-4.697 11.358-9.463 12.309-3.268.652-8.02-.419-9.382-1.841.694-.054 3.514-.357 5.144-1.55C5.16 15.7-.329 12.47 3.278 3.786c1.693 1.977 3.41 3.323 5.15 4.037 1.158.475 1.442.465 1.973.538z"/>
    </g>
</svg>

		</div>
	</a>
	
</div>
	<div class="text-sm text-gray-500 leading-tight a-gray">
		
		<br />
		14356 words in this page.
	</div>
</div>

			</div>
		</aside>
		<footer class="w-full md:w-3/5 xl:w-1/2 order-3 max-w-3xl md:order-4 pt-2">
			
<hr class="" />
<div class="flex flex-wrap justify-between pb-2 leading-loose font-serif">
    
    <a class="flex-grow-0" href="/posts/shap_exploration/">
        <svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24"
            height="24">
            <path fill="none" d="M0 0h24v24H0z" />
            <path d="M7.828 11H20v2H7.828l5.364 5.364-1.414 1.414L4 12l7.778-7.778 1.414 1.414z" /></svg>
        [Paper Exploration] A Unified Approach to Interpreting Model Predictions
    </a>
    
    
    <a class="flex-grow-0" href="/posts/transformers_for_image_paper_exploration/">
        [Paper Exploration] An Image is Worth 16x16 Words: Transformers for Image Recognition at Scale
        <svg class="fill-current inline-block h-4 w-4" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="24"
            height="24">
            <path fill="none" d="M0 0h24v24H0z" />
            <path d="M16.172 11l-5.364-5.364 1.414-1.414L20 12l-7.778 7.778-1.414-1.414L16.172 13H4v-2z" /></svg></a>
    
</div>
<div >



<div class="font-serif pb-2 flex align-start leading-loose">
	<span class="heading pr-6 leading-loose">Related</span>
	<span >
		
			<a href="/posts/ride_hailing_analytics/">Analytics for Ride Hailing Services</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/wasserstein_gan/">[Paper Exploration] Wasserstein GAN (WIP)</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/yolov3/">[Paper Exploration] YOLOv3: An Incremental Improvement(WIP)</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/machine_learning_for_trading/">Machine Learning for Trading</a>&nbsp;&nbsp;&#47;&nbsp;
		
			<a href="/posts/deterministic_optimization/">Deterministic Optimization</a>
		
</span>
</div>

</div>
<hr />
<div class="pb-2">
    
</div>
<hr />

		</footer>
		

<script src="/dist/app.js"></script>


<script src="/lib/fuse.min.js"></script> 
<script src="/lib/fastsearch.js"></script>

	</div>
</body>

</html>