<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>optimization on Ayush Subedi</title>
    <link>https://ayushsubedi.github.io/tags/optimization/</link>
    <description>Recent content in optimization on Ayush Subedi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Mon, 16 Jan 2023 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://ayushsubedi.github.io/tags/optimization/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Deterministic Optimization</title>
      <link>https://ayushsubedi.github.io/posts/deterministic_optimization/</link>
      <pubDate>Mon, 16 Jan 2023 00:00:00 +0000</pubDate>
      
      <guid>https://ayushsubedi.github.io/posts/deterministic_optimization/</guid>
      <description>&lt;h1 id=&#34;deterministic-optimization&#34;&gt;Deterministic Optimization&lt;/h1&gt;
&lt;h2 id=&#34;introduction-to-optimization-models&#34;&gt;Introduction to Optimization Models&lt;/h2&gt;
&lt;h3 id=&#34;generic-form-of-optimization-problem&#34;&gt;Generic form of optimization problem:&lt;/h3&gt;
&lt;p&gt;$min$ $f(x)$ $s.t.$ $x \in X $&lt;/p&gt;
&lt;h3 id=&#34;example-designing-a-box&#34;&gt;Example: Designing a box:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Given a $1$ feet by $1$ feet piece of cardboard, cut out corners and fold to make a box of maximum volume:&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;Decision:&lt;/strong&gt; $x$ = how much to cut from each of the corners?&lt;br/&gt;
&lt;strong&gt;Alternatives:&lt;/strong&gt; $0&amp;lt;=x&amp;lt;=1/2$&lt;br/&gt;
&lt;strong&gt;Best:&lt;/strong&gt; Maximize volume: $V(x) = x(1-2x)^2$ ($x$ is the height and $(1-2x)^2$ is the base, and their product is the volume)&lt;br/&gt;
&lt;strong&gt;Optimization formulation:&lt;/strong&gt; $max$ $x(1-2x)^2$ subject to $0&amp;lt;=x&amp;lt;=1/2$ (which are the constraints in this case)&lt;br/&gt;&lt;/p&gt;
&lt;iframe src=&#34;https://www.desmos.com/calculator/ily45jyfsv?embed&#34; width=&#34;100%&#34; height=&#34;500&#34; style=&#34;border: 1px solid #ccc&#34; frameborder=0&gt;&lt;/iframe&gt;
&lt;h3 id=&#34;example-data-fitting&#34;&gt;Example: Data Fitting:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Given $N$ data points $(y_1, x_1)&amp;hellip;(y_N, x_N)$ where $y_i$ belongs to $\mathbb{R}$ and $x_i$ belongs to $\mathbb{R}^n$, for all $i = 1..N$, find a line $y = a^Tx+b$ that best fits the data.&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;Decision&lt;/strong&gt;: A vector $a$ that belongs to $\mathbb{R}^n$ and a scalar $b$ that belongs to $\mathbb{R}$&lt;br/&gt;
&lt;strong&gt;Alternatives&lt;/strong&gt;: All $n$-dimensional vectors and scalars&lt;br/&gt;
&lt;strong&gt;Best&lt;/strong&gt;: Minimise the sum of squared errors&lt;br/&gt;
&lt;strong&gt;Optimization formulation&lt;/strong&gt;:
$\begin{array}{ll}\min &amp;amp; \sum_{i=1}^N\left(y_i-a^{\top} x_i-b\right)^2 \ \text { s.t. } &amp;amp; a \in \mathbb{R}^n, b \in \mathbb{R}\end{array}$&lt;/p&gt;
&lt;h3 id=&#34;example-product-mix&#34;&gt;Example: Product Mix:&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;A firm make $n$ different products using $m$ types of resources. Each unit of product $i$ generates $p_i$ dollars of profit, and requires $r_{ij}$ units of resource $j$. The firm has $u_j$ units of resource $j$ available. How much of each product should the firm make to maximize profits?&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;Decision&lt;/strong&gt;: how much of each product to make&lt;br/&gt;
&lt;strong&gt;Alternatives&lt;/strong&gt;: defined by the resource limits&lt;br/&gt;
&lt;strong&gt;Best&lt;/strong&gt;: Maximize profits&lt;br/&gt;
&lt;strong&gt;Optimization formulation:&lt;/strong&gt; &lt;br/&gt;
Sum notation: $\begin{array}{lll}\max &amp;amp; \sum_{i=1}^n p_i x_i \ \text { s.t. } &amp;amp; \sum_{i=1}^n r_{i j} x_i \leq u_j &amp;amp; \forall j=1, \ldots, m \ &amp;amp; x_i \geq 0 &amp;amp; \forall i=1, \ldots, n\end{array}$ &lt;br/&gt;
Matrix notation: $\begin{array}{cl}\max &amp;amp; p^{\top} x \ \text { s.t. } &amp;amp; R x \leq u \ &amp;amp; x \geq 0\end{array}$&lt;/p&gt;
&lt;h3 id=&#34;example-project-investment&#34;&gt;Example: Project investment&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt; A firm is considering investing in $n$ different R&amp;amp;D projects. Project $j$ requires an investment of $c_j$ dollars and promises a return of $r_j$ dollars. The firm has a budget of $B$ dollars. Which projects should the firm invest in?&lt;/strong&gt;&lt;br/&gt;
&lt;strong&gt;Decision&lt;/strong&gt;: Whether or not to invest in project&lt;br/&gt;
&lt;strong&gt;Alternatives&lt;/strong&gt;: Defined by budget&lt;br/&gt;
&lt;strong&gt;Best&lt;/strong&gt;: Maximize return on investment&lt;br/&gt;
Sum notation: $\begin{aligned} \max &amp;amp; \sum_{j=1}^n r_j x_j \ \text { s.t. } &amp;amp; \sum_{j=1}^n c_j x_j \leq B \ &amp;amp; x_j \in{0,1} \forall j=1, \ldots, n\end{aligned}$ &lt;br/&gt;
Matrix notation: $\begin{aligned} \max  &amp;amp; r^{\top} x \ \text { s.t. } &amp;amp; c^{\top} x \leq B \ &amp;amp; x \in{0,1}^n\end{aligned}$&lt;/p&gt;
&lt;h2 id=&#34;mathematical-ingredients-of-an-optimization-model&#34;&gt;Mathematical ingredients of an optimization model:&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Encode decisions/actions as &lt;strong&gt;decision variables&lt;/strong&gt; whose values we are seeking&lt;/li&gt;
&lt;li&gt;Identify the relevant &lt;strong&gt;problem data&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;Express &lt;strong&gt;constraints&lt;/strong&gt; on the values of the decision variables as mathematical relationships (inequalities) between the variables and problem data&lt;/li&gt;
&lt;li&gt;Express the &lt;strong&gt;objective function&lt;/strong&gt; as a function of the decision variables and the problem data.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Minimize or Maximize an objective function of decision variable subject to constraints on the values of the decision variables.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;min or max f(x1, x2, .... , xn)
subject to gi(x1, x2, ...., ) &amp;lt;= bi     i = 1,....,m 
        xj is continuous or discrete    j = 1,....,n
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;the-problem-setting&#34;&gt;The problem setting&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Finite number of decision variables&lt;/li&gt;
&lt;li&gt;A single objective function of decision variables and problem data
&lt;ul&gt;
&lt;li&gt;Multiple objective functions are handled by either taking a weighted combination of them or by optimizing one of the objectives while ensuring the other objectives meet target requirements.&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;The constraints are defined by a finite number of inequalities or equalities involving functions of the decision variables and problem data&lt;/li&gt;
&lt;li&gt;There may be domain restrictions (continious or discrete) on some of the variables&lt;/li&gt;
&lt;li&gt;The functions defining the objective and constraints are algebraic (typically with rational coeffiicients)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minimization-vs-maximization&#34;&gt;Minimization vs Maximization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Without the loss of generality, it is sufficient to consider a minimization objective since maximization of objective function is minimization of the negation of the objective function&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;program-vs-optimization&#34;&gt;Program vs optimization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A program or mathematical program is an optimization problem with a finite number of variables and constraints written out using explicit mathematical (algebraic) expressions&lt;/li&gt;
&lt;li&gt;The word program means plan/planning&lt;/li&gt;
&lt;li&gt;Early application of optimization arose in planning resource allocations and gave rise to programming to mean optimization (predates computer programming)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;classification-of-optimization-problems&#34;&gt;Classification of optimization problems&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;The tractability of a large scale optimization problem depends on the structure of the functions that make up the objective and constraints, and the domain restrictions on the variables.&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Functions&lt;/th&gt;
&lt;th&gt;Variable domains&lt;/th&gt;
&lt;th&gt;Problem Type&lt;/th&gt;
&lt;th&gt;Difficulty&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;All linear&lt;/td&gt;
&lt;td&gt;Continuous variables&lt;/td&gt;
&lt;td&gt;Linear Program&lt;/td&gt;
&lt;td&gt;Easy&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Some nonlinear&lt;/td&gt;
&lt;td&gt;Continuous variables&lt;/td&gt;
&lt;td&gt;Nonlinear Program or Nonlinear Optimization Problem&lt;/td&gt;
&lt;td&gt;Easy/Difficult&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Linear/nonlinear&lt;/td&gt;
&lt;td&gt;Some discrete&lt;/td&gt;
&lt;td&gt;Integer Problem or Discrete Optimization Problem&lt;/td&gt;
&lt;td&gt;Difficult&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;subclasses-of-nlp-non-linear-problem&#34;&gt;Subclasses of NLP (Non Linear Problem)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Unconstrained optimization: No constraints or simple bound constraints on the variables (Box design example above)&lt;/li&gt;
&lt;li&gt;Quadrative programming: objectives and constraints involve quadratic functions (Data fitting example above), subset of NLP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;subclasses-of-ip-integer-programming&#34;&gt;Subclasses of IP (Integer Programming)&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Mixed Integer Linear Program
&lt;ul&gt;
&lt;li&gt;All linear functions&lt;/li&gt;
&lt;li&gt;Some variables are continous and some are discrete&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mixed Integer Nonlinear Program (MINLP)
&lt;ul&gt;
&lt;li&gt;Some nonlinear functions&lt;/li&gt;
&lt;li&gt;Some variables are continous and some are discrete&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Mixed Integer Quadratic Program (MIQLP)
&lt;ul&gt;
&lt;li&gt;Nonlinear functions are quadratic&lt;/li&gt;
&lt;li&gt;Some variables are continuous and some are discrete&lt;/li&gt;
&lt;li&gt;subset of MINLP&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;why-and-how-to-classify&#34;&gt;Why and how to classify?&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Important to recognize the type of an optimization problem:
&lt;ul&gt;
&lt;li&gt;to formulate problems to be amenable to certain solution methods&lt;/li&gt;
&lt;li&gt;to anticipate the difficulty of solving the problem&lt;/li&gt;
&lt;li&gt;to know which solution methods to use&lt;/li&gt;
&lt;li&gt;to design customized solution methods&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;how to classify:
&lt;ul&gt;
&lt;li&gt;check domain restriction on variables&lt;/li&gt;
&lt;li&gt;check the structure of the functions involved&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;portfolio-optimization-problem&#34;&gt;Portfolio Optimization Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Identify basic portfolio optimization and associated issues&lt;/li&gt;
&lt;li&gt;Examine the Markowitz Portfolio Optimization approach
&lt;ul&gt;
&lt;li&gt;Markowitz Principle: Select a portfolio that attempts to maximize the expected return and minimize the variance of returns (risk)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;For multi objective problem (like defined by the Markowitz Principle), two objectives can be combined:
&lt;ul&gt;
&lt;li&gt;Maximize Expected Return - $\lambda$*risk&lt;/li&gt;
&lt;li&gt;Maximize Expected Return subject to risk &amp;lt;= s_max (constraint on risk)&lt;/li&gt;
&lt;li&gt;Minimize Risk subject to return &amp;gt;= r_min (threshold on expected returns)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Optimization Problem Statement&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;Given $1000, how much should we invest in each of the three stocks MSFT, V and WMT so as to :
- have a one month expected return of at least a given threshold
- minimize the risk(variance) of the portfolio return
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Decision: investment in each stock&lt;/li&gt;
&lt;li&gt;alternatives: any investment that meets the budget and the minimum expected return requirement&lt;/li&gt;
&lt;li&gt;best: minimize variance&lt;/li&gt;
&lt;li&gt;Key trade-off: How much of the detail of the actual problem to consider while maintaining computational tractability of the mathematical model?&lt;/li&gt;
&lt;li&gt;Requires making simplifying assumptions, either because some of the problem characteristics are not well-defined mathematically, or because we wish to develop a model that can actually be solved&lt;/li&gt;
&lt;li&gt;Need to exercise great caution in these assumptions and not loose sight of the true underlying problem&lt;/li&gt;
&lt;li&gt;Assumptions:
&lt;ul&gt;
&lt;li&gt;No transaction cost&lt;/li&gt;
&lt;li&gt;Stocks does not need to be bought in blocks (any amount &amp;gt;=0 is fine)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Optimization Process: Decision Problem -&amp;gt; Model -&amp;gt; Data Collection -&amp;gt; Model Solution -&amp;gt; Analysis -&amp;gt; Problem solution&lt;/li&gt;
&lt;li&gt;No clear cut recipe&lt;/li&gt;
&lt;li&gt;Lots of feedbacks and iterations&lt;/li&gt;
&lt;li&gt;Approximations and assumptions involved in each stage&lt;/li&gt;
&lt;li&gt;Success requires good understanding of the actual problem (domain knowledge is important)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;notes-from-linear-algebra&#34;&gt;Notes from Linear Algebra&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A vector is a mathematical object that has both a magnitude (size) and a direction. Vectors are often used to represent physical quantities such as velocity or force. In two-dimensional space, a vector is represented by an ordered pair of numbers (x, y), and in three-dimensional space, it is represented by an ordered triple (x, y, z). Vectors can be added and subtracted, and multiplied by a scalar (a single number). They also have properties such as the dot product and cross product. In computer science and programming, a vector is also a data structure that can store multiple values of the same type.&lt;/li&gt;
&lt;li&gt;The vectors $x$ and $y$ are orthogonal if $x^Ty=0$, they make an acute angle if $x^Ty&amp;gt;0$ and an obtuse angle if $x^Ty&amp;lt;0$&lt;/li&gt;
&lt;li&gt;Also, $x^Ty=||x||.||y||cos\theta$&lt;/li&gt;
&lt;li&gt;A set of vectors are linearly independent if none of the vectors can be written as a linear combination of the others. That is the unique solution to the system of equations. There can be at most $n$ linearly independent vectors in $R^n$&lt;/li&gt;
&lt;li&gt;Any collection of $n$ linearly independent vectors in $R$ defines a basis (or a coordinate system) of $R^n$, any vector in $R^n$ can be written as a linear combination of the basis vectors  The unit vectors $e^1= [1, 0, &amp;hellip;0]^T$, $e^2= [0, 1, &amp;hellip;0]^T$,&amp;hellip;,$e^n= [0, 0, &amp;hellip;1]^T$, define the standard basis for $R^n$&lt;/li&gt;
&lt;li&gt;The rank of a matrix is a measure of the &amp;ldquo;nondegeneracy&amp;rdquo; of the matrix and it is one of the most important concepts in linear algebra. It is defined as the dimension of the vector space spanned by its columns or rows. Intuitively, it represents the number of linearly independent columns or rows in the matrix. $row rank = column rank = rank(A)$. $A$ is full rank if $rank(A) = min(m, n)$&lt;/li&gt;
&lt;li&gt;A system of equations has a solution when the equations are consistent, meaning that there is at least one set of values for the variables that satisfies all of the equations. If the equations are inconsistent, meaning that there is no set of values that satisfies all of the equations, then the system of equations has no solution.&lt;/li&gt;
&lt;li&gt;An affine function is a function that is defined as a linear combination of variables, with the addition of a constant term. An affine function can be written as:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;f(x) = a_1x_1 + a_2x_2 + ... + a_nx_n + b
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;Where x_1, x_2, &amp;hellip;, x_n are the input variables, a_1, a_2, &amp;hellip;, a_n are the coefficients, and b is a constant term. An affine function is a generalization of a linear function, which does not have the constant term.&lt;/p&gt;
&lt;iframe width=&#34;100%&#34; height =&#34;1024&#34; src=&#34;https://www.aerostudents.com/courses/linear-algebra/linearAlgebraFullVersion.pdf#toolbar=0&#34;&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;notes-from-multivariate-calculus&#34;&gt;Notes from Multivariate Calculus&lt;/h2&gt;
&lt;h3 id=&#34;hessian-matrix&#34;&gt;Hessian matrix&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Hessian matrix is a square matrix of second-order partial derivatives of a scalar-valued function of multiple variables.&lt;/li&gt;
&lt;li&gt;The Hessian matrix of a scalar-valued function f(x) of n variables x = (x1, x2, &amp;hellip;, xn) is defined as the matrix of second-order partial derivatives of f with respect to x, with the i-th row and j-th column containing the second partial derivative of f with respect to xi and xj.&lt;/li&gt;
&lt;li&gt;The Hessian matrix is often used in optimization, for example, to find the local minima or maxima of a function. A point where the Hessian is positive definite is a local minimum, while a point where the Hessian is negative definite is a local maximum. If the Hessian is positive semi-definite, it&amp;rsquo;s a saddle point.&lt;/li&gt;
&lt;li&gt;It is important to notice that the Hessian Matrix is symmetric, therefore it has real eigenvalues and it is diagonalisable.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;taylor-approximation&#34;&gt;Taylor Approximation&lt;/h3&gt;
&lt;p&gt;The Taylor series of a real or complex-valued function f (x) that is infinitely differentiable at a real or complex number a is the power series.
Let $f: \mathbb{R}^n \rightarrow \mathbb{R}$ be a differentiable function and $\mathbf{x}^0 \in \mathbb{R}^n$.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;First order Taylor&amp;rsquo;s approximation of $f$ at $\mathbf{x}^0$ :
$$
f(\mathbf{x}) \approx f\left(\mathbf{x}^0\right)+\nabla f\left(\mathbf{x}^0\right)^{\top}\left(\mathbf{x}-\mathbf{x}^0\right)
$$&lt;/li&gt;
&lt;li&gt;Second order Taylor&amp;rsquo;s approximation of $f$ at $\mathbf{x}^0$ :
$$
f(\mathbf{x}) \approx f\left(\mathbf{x}^0\right)+\nabla f\left(\mathbf{x}^0\right)^{\top}\left(\mathbf{x}-\mathbf{x}^0\right)+\frac{1}{2}\left(\mathbf{x}-\mathbf{x}^0\right)^{\top} \nabla^2 f\left(\mathbf{x}^0\right)\left(\mathbf{x}-\mathbf{x}^0\right)
$$
`&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sets-in-optimization-problems&#34;&gt;Sets in Optimization Problems&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A set is closed if it includes its boundary points.&lt;/li&gt;
&lt;li&gt;Intersection of closed sets is closed.&lt;/li&gt;
&lt;li&gt;Typically, if none of inequalities are strict, then the set is closed.&lt;/li&gt;
&lt;li&gt;A set is convex if a line segment connecting two points in the set lies entirely in the set.&lt;/li&gt;
&lt;li&gt;A set is bounded if it can be enclosed in a large enough (hyper)-sphere or a box.&lt;/li&gt;
&lt;li&gt;A set that is both bounded and closed is called compact.
&lt;ul&gt;
&lt;li&gt;$R^2$ is closed but not bounded&lt;/li&gt;
&lt;li&gt;$x^2+y^2&amp;lt;1$ is bounded but not closed&lt;/li&gt;
&lt;li&gt;$x+y&amp;gt;=1$ is closed but not bounded&lt;/li&gt;
&lt;li&gt;$x^2+y^2&amp;lt;=1$ is closed and bounded (compact)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;iframe src=&#34;https://www.desmos.com/calculator/49e59msg7u?embed&#34; width=&#34;100%&#34; height=&#34;500&#34; style=&#34;border: 1px solid #ccc&#34; frameborder=0&gt;&lt;/iframe&gt;
&lt;h2 id=&#34;convex-function&#34;&gt;Convex Function&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;A function $f: \mathbb{R}^n \rightarrow \mathbb{R}$ is convex if
$$
f(\lambda \mathbf{x}+(1-\lambda) \mathbf{y}) \leq \lambda f(\mathbf{x})+(1-\lambda) f(\mathbf{y}) \quad \forall \mathbf{x}, \mathbf{y} \in \mathbb{R}^n \text { and } \lambda \in[0,1]
$$&lt;/li&gt;
&lt;li&gt;Function value at the average is less than the average of the function values&lt;/li&gt;
&lt;li&gt;This also implies that $a^Tx+b$ is convex (and concave)&lt;/li&gt;
&lt;li&gt;For a convex function the first order Taylor&amp;rsquo;s approximation is a global under estimator&lt;/li&gt;
&lt;li&gt;A convex optimization problem has a convex objective and convex set of solutions.&lt;/li&gt;
&lt;li&gt;Linear programs (LPs) can be seen as a special case of convex optimization problems. In an LP, the objective function and constraints are linear, which means that the feasible region defined by the constraints is a convex set. As a result, the optimal solution to an LP is guaranteed to be at a vertex (corner) of the feasible region, which makes it a convex optimization problem.&lt;/li&gt;
&lt;li&gt;A twice differentiable univariate function is convex if the Hessian matrix is positive semi definite.&lt;/li&gt;
&lt;li&gt;A positive semi-definite (PSD) matrix is a matrix that is symmetric and has non-negative eigenvalues. In the context of a Hessian matrix, it represents the second-order partial derivatives of a multivariate function and reflects the curvature of the function. If the Hessian is PSD, it indicates that the function is locally convex, meaning that it has a minimum value in the vicinity of that point. On the other hand, if the Hessian is not PSD, the function may have a saddle point or be locally non-convex. The PSD property of a Hessian matrix is important in optimization, as it guarantees the existence of a minimum value for the function.&lt;/li&gt;
&lt;li&gt;Sylvester&amp;rsquo;s criterion is a method for determining if a matrix is positive definite or positive semi-definite. The criterion states that a real symmetric matrix is positive definite if and only if all of its leading principal minors (i.e. determinants of the submatrices formed by taking the first few rows and columns of the matrix) are positive. If all the leading principal minors are non-negative, then the matrix is positive semi-definite.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;operations-preserving-convexity&#34;&gt;Operations preserving convexity&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Nonnegative weighted sum of convex functions is convex, i.e. if $f_i$ is convex and $\alpha_i \geq 0$ for all $i=1, \ldots, m$, then $g(\mathbf{x})=\sum_{i=1}^m \alpha_i f_i(\mathbf{x})$ is convex.&lt;/li&gt;
&lt;li&gt;Maximum of convex functions is convex.&lt;/li&gt;
&lt;li&gt;Composition: Let $f: \mathbb{R}^m \rightarrow \mathbb{R}$ be a convex function, and $g_i: \mathbb{R}^n \rightarrow \mathbb{R}$ be convex for all $i=1, \ldots, m$. Then the composite function
$$
h(\mathbf{x})=f\left(g_1(\mathbf{x}), g_2(\mathbf{x}), \ldots, g_m(\mathbf{x})\right)
$$
is convex if either $f$ is nondecreasing or if each $q_i$ is a linear function.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;convex-optimization-problem&#34;&gt;Convex Optimization Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;An optimization problem (in minimization) form is a convex optimization problem, if the objective function is a convex function and constraint set is a convex set.&lt;/li&gt;
&lt;li&gt;The problem $min$ ${f(x) :  x \in X}$ is a convex optimization problem if $f$ is a convex function and $X$ is a convex set.&lt;/li&gt;
&lt;li&gt;To check if a given problem is convex, we can check convexity of each cnstraint separately. (This is a sufficient test, not necessary).&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;sufficient-and-necessary&#34;&gt;Sufficient and necessary&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;In mathematical logic, the terms &amp;ldquo;sufficient&amp;rdquo; and &amp;ldquo;necessary&amp;rdquo; are used to describe the relationship between two conditions.&lt;/li&gt;
&lt;li&gt;A condition A is considered &amp;ldquo;sufficient&amp;rdquo; for a condition B if whenever condition A is true, condition B is also guaranteed to be true. In other words, if A is sufficient for B, then having A implies having B.&lt;/li&gt;
&lt;li&gt;A condition B is considered &amp;ldquo;necessary&amp;rdquo; for a condition A if whenever condition B is false, condition A is also guaranteed to be false. In other words, if B is necessary for A, then not having B implies not having A.&lt;/li&gt;
&lt;li&gt;Together, &amp;ldquo;necessary and sufficient&amp;rdquo; means that the two conditions are equivalent, in the sense that if one is true, then the other must also be true, and if one is false, then the other must also be false. In mathematical terms, A is necessary and sufficient for B if and only if (A if and only if B).&lt;/li&gt;
&lt;li&gt;&amp;ldquo;being a male is a necessary condition for being a brother, but it is not sufficient — while being a male sibling is a necessary and sufficient condition for being a brother&amp;rdquo;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;epigraph-of-a-function&#34;&gt;Epigraph of a function&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Epigraph_convex.svg/660px-Epigraph_convex.svg.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;An epigraph of a function is a graphical representation of the function&amp;rsquo;s domain and range. It is formed by the region above the graph of the function and the line x = a for some value of a. The epigraph represents all possible values of the function for all values of x greater than or equal to a. It is used in optimization problems to visualize the feasible region for the optimization variable.&lt;/li&gt;
&lt;li&gt;A function (in black) is convex if and only if the region above its graph (in green) is a convex set. This region is the function&amp;rsquo;s epigraph.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;outcomes-of-optimization&#34;&gt;Outcomes of Optimization&lt;/h2&gt;
&lt;h3 id=&#34;possible-outcomes-of-optimization&#34;&gt;Possible Outcomes of Optimization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Any $x \in X$ is a feasible solution of the optimization problem (P)&lt;/li&gt;
&lt;li&gt;Feasible solution = A solution that satisfies all the constraints&lt;/li&gt;
&lt;li&gt;An unbounded problem must be feasible&lt;/li&gt;
&lt;li&gt;An optimization problem is unbounded, if there are feasible solutions with arbitrarily small objective values.&lt;/li&gt;
&lt;li&gt;If $X=\emptyset$ then no feasible solutions exist, and the problem (P) is said to be infeasible.&lt;/li&gt;
&lt;li&gt;The problem $\min {3x+ 2y: x+ y&amp;lt;=1,x&amp;gt;=2,y&amp;gt;=2}$ is infeasible&lt;/li&gt;
&lt;li&gt;An optimization problem can have 4 possible outcomes. The outcome can be infeasible, unbounded, have no optimal solution, have one optimal solution, or have multiple optimal solutions&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;existence-of-optimal-solutions&#34;&gt;Existence of Optimal Solutions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Weierstrass extreme value theorem asserts that if you minimize a continuous function over a closed and bounded set in $R_n$, then the minimum will be achieved at some point in the set.&lt;/li&gt;
&lt;li&gt;Sufficient conditions: if the constraint set is bounded and non empty (feasible), then continuity and closedness guarantees an optimal solution exist.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;local-and-global-optimal-solutions&#34;&gt;Local and Global Optimal Solutions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Local optimal solutions are also global optimal solutions for convex optimization problems&lt;/li&gt;
&lt;li&gt;Every global optimal solution is a local optimal solution, but not vice versa&lt;/li&gt;
&lt;li&gt;The objective function value at different local optimal solutions may be different&lt;/li&gt;
&lt;li&gt;The objective funtion value at all global solutions must be the same&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;idea-of-improving-search&#34;&gt;Idea of Improving Search&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Most optimization algorithms are based on the paradigm of improving search:
&lt;ul&gt;
&lt;li&gt;Start from a feasible solution&lt;/li&gt;
&lt;li&gt;Move to a new feasible solution with a better objective value, Stop if not possible&lt;/li&gt;
&lt;li&gt;Repeat step 2&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;In general, we are only able to look in the &amp;ldquo;neighbourhood&amp;rdquo; of the current solution in search of a better feasible solution (solutions that are within a small positive distance from the current solution)&lt;/li&gt;
&lt;li&gt;The move direction and step size should ensure that the new point is fesible and has an improved objective function value&lt;/li&gt;
&lt;li&gt;The improving search is better for local solutions, but for convex, in principal it can be used to find global solutions (by definition)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;optimality-certificates&#34;&gt;Optimality Certificates&lt;/h2&gt;
&lt;h3 id=&#34;optimality-certificates-and-relaxations&#34;&gt;Optimality Certificates and Relaxations&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A certificate or a stopping condition is an easily checkable condition such that if the current solution satisfies this condition then it is guaranteed to be optimal or near optimal&lt;/li&gt;
&lt;li&gt;Lower bound allows us to get upper bound on the gap&lt;/li&gt;
&lt;li&gt;For two optimization problem (P) $min$ $f(x)$ $s.t.$ $x \in X $ and (Q) $min$ $g(x)$ $s.t.$ $x \in Y $, Problem (Q) is a relaxation of P if $X \subseteq Y$ and $f(x) &amp;gt;= g(x) \forall x \in X $&lt;/li&gt;
&lt;li&gt;obtained by enlarging the feasible region and underapproximating the objective function. we do not have to do both of those (see equals to sign)&lt;/li&gt;
&lt;li&gt;Relaxation in optimization refers to the process of modifying or loosening the constraints of an optimization problem to make it easier to solve. The relaxed problem provides an approximate solution, which can then be improved by tightening the constraints.&lt;/li&gt;
&lt;li&gt;Optimal value of the relaxation provides a lower bound on the original problem&lt;/li&gt;
&lt;li&gt;If the relaxation is infeasible then clearly the original problem is also infeasible&lt;/li&gt;
&lt;li&gt;Suppose only the constraints are relaxed, then if a solution to the relaxation is fesible to the original problem then it must be an optimal solution to the original problem&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lagrangian-relaxation-and-duality&#34;&gt;Lagrangian Relaxation and Duality&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Lagrangian relaxation is a method used in optimization to solve a difficult problem by relaxing some of its constraints and instead optimizing a modified objective function known as the Lagrangian function. The Lagrangian function is constructed by adding a penalty term for each constraint to the original objective function. The penalty term is multiplied by a non-negative Lagrange multiplier that represents the slack in the constraint. By choosing appropriate values for the multipliers, the relaxed problem can be made to approximate the original problem.&lt;/li&gt;
&lt;li&gt;The dual problem attempts to find the relaxation with the tightest bound&lt;/li&gt;
&lt;li&gt;Weak duality: dual optimal value &amp;lt;= original optimal value&lt;/li&gt;
&lt;li&gt;Some times we get strong duality&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unconstrained-optimization-derivative-based&#34;&gt;Unconstrained Optimization: Derivative Based&lt;/h2&gt;
&lt;h3 id=&#34;optimality-conditions&#34;&gt;Optimality Conditions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Unconstrained, that is the constraints are only $x \in R^n$ and twice differentiable&lt;/li&gt;
&lt;li&gt;If a solution is a local optimal solution of an unconstrained problem, then the gradient vanishes at the point (First order optimality condition)&lt;/li&gt;
&lt;li&gt;Hessian is a positive semidefinite (Second order optimality condition)&lt;/li&gt;
&lt;li&gt;The conditions are necessary but not sufficient&lt;/li&gt;
&lt;li&gt;For example for, $f(x)=x^3$, at point 0, both of the conditions are satisfied. However, it is neither a local min or max&lt;/li&gt;
&lt;li&gt;A sufficient (but not necessary) condition would be the gradient vanishing at the point, and is the Hessian is positive definite.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;gradient-descent&#34;&gt;Gradient Descent&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The gradient descent method moves from one iteration to the next by moving along the negative of the gradient direction in order to minimize the function.&lt;/li&gt;
&lt;li&gt;Gradient descent is a optimization algorithm used to minimize the error of a machine learning model. It is an iterative method that updates the model parameters in the direction of the negative gradient of the cost function with respect to the parameters. The gradient indicates the direction of steepest increase in the cost function and the descent refers to moving in the direction of negative gradient to find the minimum of the cost function. The learning rate determines the size of the steps taken to reach the minimum and the algorithm stops when the change in cost is below a certain threshold or when a maximum number of iterations is reached.&lt;/li&gt;
&lt;li&gt;Let $x^k$ be the current iterate, and we want to chose a downhill direction $d^k$ and a step size $a$ such that $f(x^k+ad^k)&amp;lt;f(x^k)$&lt;/li&gt;
&lt;li&gt;By Taylor&amp;rsquo;s expansion, $f(x^k+ad^k) \approx f(x^k) + a \nabla f(x^k)^Td_k$&lt;/li&gt;
&lt;li&gt;So we want $\nabla f(x^k)^Td_k &amp;lt; 0$. The steepest descent direction is $d^k = - \nabla f(x^k) $&lt;/li&gt;
&lt;li&gt;Step size can be identified using a line search. That is, define a function $g(a) := f(x^k + ad^k)$. Choose $a$ to minimize $g$. It can also be a small fixed step size.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;newtons-method&#34;&gt;Newton&amp;rsquo;s Method&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Newton&amp;rsquo;s Method is a second-order optimization algorithm that is used to find the minimum of a function. It is an iterative method that updates the parameters by using the gradient of the function (first derivative) and the Hessian matrix (second derivative) to find the direction of the local minimum. The algorithm starts with an initial guess for the parameters and iteratively updates them using the Newton-Raphson formula until the change in the parameters is below a certain threshold or a maximum number of iterations is reached. Newton&amp;rsquo;s Method is faster and more precise than gradient descent for well-behaved functions, but it can be sensitive to poor initialization and can get stuck in local minima.&lt;/li&gt;
&lt;li&gt;$x^{k+1} $ = $x^k$ - $[\nabla^2$ $f(x_k)]^{-1}$ $ \nabla f(x^k)$&lt;/li&gt;
&lt;li&gt;If started close enough to local minimum and the Hessian is positive definite, then the method has quadratic convergence&lt;/li&gt;
&lt;li&gt;Not guarenteed to converge. The Newton direction may not be improving at all.&lt;/li&gt;
&lt;li&gt;If the Hessian is singular ( or close to singular) at some iteration, we cannot proceed.&lt;/li&gt;
&lt;li&gt;Computing gradient as well as the Hessian and its inverse is expensive&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;quasi-netwon-methods&#34;&gt;Quasi-Netwon Methods&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Blend of gradient descent and Newton&amp;rsquo;s method.&lt;/li&gt;
&lt;li&gt;Avoids computation of Hessian and its inverse&lt;/li&gt;
&lt;li&gt;$x^{k+1} $ = $x^k$ - $a_k H_k$ $ \nabla f(x^k)$, where $H_k$ is an approximation of $[\nabla^2$ $f(x_k)]^{-1}$ and $a_k$ is determined by line search&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;unconstrained-optimization-derivative-free&#34;&gt;Unconstrained Optimization: Derivative Free&lt;/h2&gt;
&lt;h3 id=&#34;methods-for-univariate-functions&#34;&gt;Methods for Univariate Functions&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Golden Section Search: Start with an initial interval $[x_l, x_u]$ containing the minima, and successively narrow this interval&lt;/li&gt;
&lt;li&gt;Golden Section Search is an optimization algorithm used to find the minimum of a unimodal function, i.e., a function with a single minimum. The method is based on the idea of dividing an interval that contains the minimum into three sections, with the middle section being proportional to the golden ratio. The algorithm iteratively narrows down the interval by selecting the section that contains the minimum and discards the other sections. The process continues until the interval is sufficiently small and the minimum can be approximated with a desired accuracy. Golden Section Search is a bracketing method, which means it only requires the function to be unimodal and does not require the derivative or any other information about the function. It is a simple and efficient method for finding the minimum of unimodal functions, but it is slower than more sophisticated optimization methods for functions with multiple minima or more complex structures.&lt;/li&gt;
&lt;li&gt;Step 0: Set $x_1 = x_u - a(x_u-x_l)$ and $x_2=x_l+a(x_u-x_l)$&lt;/li&gt;
&lt;li&gt;Step 1: If $(x_u-x_l) &amp;lt;= \epsilon$ stop and return $x^* = 0.5(x_l+x_u)$ as the minima&lt;/li&gt;
&lt;li&gt;Example of how to use scipy.optimize.minimize to minimize a scalar function:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import numpy as np
from scipy.optimize import minimize

def objective_function(x):
    return x**2 + 5*np.sin(x)

x0 = np.array([1.0]) # Initial guess
result = minimize(objective_function, x0, method=&amp;#39;BFGS&amp;#39;)
print(&amp;#34;Minimum at:&amp;#34;, result.x)
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;methods-for-multivariate-function&#34;&gt;Methods for Multivariate Function&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;https://upload.wikimedia.org/wikipedia/commons/d/de/Nelder-Mead_Himmelblau.gif&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The Nelder-Mead method is a optimization algorithm used to minimize a scalar function of several variables. It is a derivative-free method, meaning that it does not require the gradient of the objective function to be calculated. It works by constructing a simplex (a set of vertices) in the high-dimensional space defined by the input variables, and then iteratively modifying the vertices to find the minimum.&lt;/li&gt;
&lt;li&gt;Here&amp;rsquo;s an example of how to use scipy.optimize.minimize with the Nelder-Mead method:&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;import numpy as np
from scipy.optimize import minimize

def objective_function(x):
    return x**2 + 5*np.sin(x)

x0 = np.array([1.0]) # Initial guess
result = minimize(objective_function, x0, method=&amp;#39;Nelder-Mead&amp;#39;)
print(&amp;#34;Minimum at:&amp;#34;, result.x)
&lt;/code&gt;&lt;/pre&gt;&lt;ul&gt;
&lt;li&gt;Nelder-Mead method is a numerical algorithm for minimizing a multivariate function using only function evaluations&lt;/li&gt;
&lt;li&gt;It is not guaranteed to converge but often works well.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;linear-optimization-modeling---network-flow-problems&#34;&gt;Linear Optimization Modeling - Network Flow Problems&lt;/h2&gt;
&lt;h3 id=&#34;introduction-to-lp-modeling&#34;&gt;Introduction to LP Modeling&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;A linear program is composed of:
&lt;ul&gt;
&lt;li&gt;Variables $x=(x_1,x_2,x_3&amp;hellip;,x_n)$&lt;/li&gt;
&lt;li&gt;Linear objective function $f(x_1,x_2,x_3&amp;hellip;,x_n)=\sum_{i=1}^n c_i x_i = c^Tx$&lt;/li&gt;
&lt;li&gt;Linear constraints: $&amp;gt;=, &amp;lt;= or =$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;optimal-transportation-problem&#34;&gt;Optimal Transportation Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The transportation problem is a type of linear programming problem that deals with finding the optimal assignment of resources to meet a set of demands. The problem is typically framed as a network flow problem, where the goal is to find the maximum flow from a set of sources to a set of destinations.&lt;/li&gt;
&lt;li&gt;In a transportation problem, the goal is to find the least cost way to transport a given amount of goods from a set of sources (e.g. factories) to a set of destinations (e.g. warehouses) subject to certain constraints such as limited supply at the sources and limited demand at the destinations. The cost of transporting a unit of goods from a source to a destination is represented by a cost matrix, which is usually obtained through market research or historical data.&lt;/li&gt;
&lt;li&gt;There are various algorithms that can be used to solve transportation problems, including the North-West Corner Method, the Minimum Cost Method (also known as the Vogel&amp;rsquo;s Approximation Method), and the Modified Distribution Method. The most popular algorithm for solving transportation problems is the Iterative Proportional Fitting (IPF) algorithm, also known as the MODI (Modified Distribution) method.&lt;/li&gt;
&lt;li&gt;The transportation problem is an important optimization problem with numerous real-world applications, including supply chain management, distribution systems, and logistics planning.&lt;/li&gt;
&lt;li&gt;There are $m$ suppliers, $n$ customers. Supplier $i$ can supply up to $s_i$ units of supply, and customer $j$ has $d_j$ units of demand. It costs $c_{ij}$ to transport a unit of product from supplier $i$ to customer $j$. We want to find a transportation schedule to satisfy all the demand within minimum transportation cost.&lt;/li&gt;
&lt;li&gt;Formulation 1: $\begin{array}{ll}\min &amp;amp; \sum_{i=1}^m \sum_{j=1}^n c_{i j} x_{i j} \ \text { s.t. } &amp;amp; \sum_{i=1}^m x_{i j}=d_j, \quad \forall j \ &amp;amp; \sum_{j=1}^n x_{i j} \leq s_i, \quad \forall i \ &amp;amp; x_{i j} \geq 0, \quad \forall i, j .\end{array}$&lt;/li&gt;
&lt;li&gt;Formulation 2: $\begin{array}{ll}\min &amp;amp; \sum_{i=1}^m \sum_{j=1}^n c_{i j} x_{i j} \ \text { s.t. } &amp;amp; \sum_{i=1}^m x_{i j}&amp;gt;=d_j, \quad \forall j \ &amp;amp; \sum_{j=1}^n x_{i j} \leq s_i, \quad \forall i \ &amp;amp; x_{i j} \geq 0, \quad \forall i, j .\end{array}$&lt;/li&gt;
&lt;li&gt;But &amp;gt;= inequality in the second formulation will be satisfied as = at optimal solution, thus, the two formulations are equivalent&lt;/li&gt;
&lt;li&gt;The graphs here are bipartite&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;maximum-flow-problem&#34;&gt;Maximum Flow Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The maximum flow problem is a classical problem in network flow theory that aims to find the maximum amount of flow that can be sent from a source node to a sink node in a network, subject to capacity constraints on the edges. The maximum flow problem is a special case of the more general minimum cut problem, which aims to find the minimum capacity of a cut that separates the source and the sink in the network.&lt;/li&gt;
&lt;li&gt;A network in this context is represented as a graph, where the nodes represent the vertices and the edges represent the capacities of the arcs. The source node is where the flow originates, and the sink node is where the flow terminates. The capacity constraints on the edges determine the maximum amount of flow that can be sent through a particular edge.&lt;/li&gt;
&lt;li&gt;There are several algorithms that can be used to solve the maximum flow problem, including the Ford-Fulkerson algorithm, the Edmonds-Karp algorithm, and the push-relabel algorithm. These algorithms work by finding augmenting paths in the residual network, which is a network derived from the original network that represents the remaining capacities of the edges after some flow has already been sent. The algorithms continue to find augmenting paths until no more can be found, at which point the maximum flow has been found.&lt;/li&gt;
&lt;li&gt;The maximum flow problem has many real-world applications, including traffic flow in transportation networks, the allocation of bandwidth in communication networks, and the distribution of resources in supply chain networks.&lt;/li&gt;
&lt;li&gt;The graphs here are directed&lt;/li&gt;
&lt;li&gt;$\begin{array}{ll}\max &amp;amp; b_s \ \end{array}$&lt;/li&gt;
&lt;li&gt;$\begin{array}{ll} \text { s.t. } &amp;amp; \sum_{k \in O(i)} x_{i k}-\sum_{j \in I(i)} x_{j i}=b_i \quad \forall i \ &amp;amp; b_t=-b_s \ &amp;amp; b_i=0, \quad \forall i \neq s, t \ &amp;amp; 0 \leq x_{i j} \leq u_{i j}, \quad \forall(i, j) \in \mathcal{A} .\end{array}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;minimum-cut-problem&#34;&gt;Minimum Cut Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Maximum Cut Problem is a well-known optimization problem in computer science and mathematics. The goal of the problem is to divide a given graph into two sets of vertices such that the sum of the weights of the edges between the two sets is as large as possible.&lt;/li&gt;
&lt;li&gt;Formally, given a graph G = (V,E) with a weight function w : E → R, the maximum cut problem is to find a partition of the vertices into two sets S and T such that the sum of the weights of the edges between S and T is maximized.&lt;/li&gt;
&lt;li&gt;The problem is NP-hard, meaning that finding the optimal solution is computationally infeasible for large graphs. However, there are approximate algorithms that can find near-optimal solutions, such as semidefinite programming, spectral methods, and local search algorithms.&lt;/li&gt;
&lt;li&gt;The maximum cut problem has a wide range of applications, including network design, image and signal processing, and machine learning.&lt;/li&gt;
&lt;li&gt;Minimum cut = Maximum flow&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;shortest-path-problem&#34;&gt;Shortest Path Problem&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;The Maximum Cut Problem is a well-known optimization problem in computer science and mathematics. The goal of the problem is to divide a given graph into two sets of vertices such that the sum of the weights of the edges between the two sets is as large as possible.&lt;/li&gt;
&lt;li&gt;Formally, given a graph G = (V,E) with a weight function w : E → R, the maximum cut problem is to find a partition of the vertices into two sets S and T such that the sum of the weights of the edges between S and T is maximized.&lt;/li&gt;
&lt;li&gt;The problem is NP-hard, meaning that finding the optimal solution is computationally infeasible for large graphs. However, there are approximate algorithms that can find near-optimal solutions, such as semidefinite programming, spectral methods, and local search algorithms.&lt;/li&gt;
&lt;li&gt;The maximum cut problem has a wide range of applications, including network design, image and signal processing, and machine learning.&lt;/li&gt;
&lt;li&gt;Shortest Path Problem is a Flow problem if we are shipping 1 unit of flow from $s$ to all other nodes&lt;/li&gt;
&lt;li&gt;$\begin{array}{ll}\min &amp;amp; \sum_{(i, j) \in \mathcal{A}} c_{i j} x_{i j} \ \end{array}$&lt;/li&gt;
&lt;li&gt;$\begin{array}{ll}{ s.t. } &amp;amp; \sum_{k \in O(i)} x_{i k}-\sum_{j \in I(i)} x_{j i}=-1 \forall i \neq s \ &amp;amp; \sum_{k \in O(s)} x_{s k}-\sum_{j \in I(s)} x_{j s}=n-1 \ &amp;amp; x_{i j} \geq 0, \quad \forall(i, j) \in \mathcal{A} .\end{array}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;lp-model-for-market-clearing&#34;&gt;LP model for market clearing:&lt;/h3&gt;
&lt;img src=&#34;https://ayushsubedi.github.io/img/op.png&#34; width=&#34;300&#34; height=&#34;200&#34;&gt;
</description>
    </item>
    
    <item>
      <title>Analytics for Ride Hailing Services</title>
      <link>https://ayushsubedi.github.io/posts/ride_hailing_analytics/</link>
      <pubDate>Thu, 02 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://ayushsubedi.github.io/posts/ride_hailing_analytics/</guid>
      <description>&lt;h2 id=&#34;analytics-for-ride-hailing-services&#34;&gt;Analytics for Ride Hailing Services&lt;/h2&gt;
&lt;p&gt;&lt;img src=&#34;https://cdn.sanity.io/images/6xsct86j/production/e8fc0f789129b17cc8ae2e05b91e93d0752bef67-3840x2160.png&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;h2 id=&#34;introduction-to-ride-hailing&#34;&gt;Introduction to Ride Hailing&lt;/h2&gt;
&lt;p&gt;At present, it is pretty common to hail a ride to get from one place to the other at a tap of a button. Almost all major cities in the world have some sort of ride-hailing service. Uber, Lyft, Didi, Ola, Gojek, etc. are some examples of service providers that come to mind. Additionally, the service is also proliferating to smaller cities and has become commonplace in many parts of the world. Analytics is a key component in making sure the service is provided efficiently. All of the aforementioned companies invest heavily in data science and analytics to be competitive and to provide better services.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this post, I will focus on Ride-Hailing services (not Ride Sharing services). See the difference &lt;a href=&#34;https://www.ecolane.com/blog/ride-hailing-vs.-ride-sharing-the-key-difference-and-why-it-matters&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Predominantly, ride-hailing functions as a &lt;em&gt;Gig Economy&lt;/em&gt;. The drivers (sometimes referred to as partners, captains, etc.) are mostly independent contractors who bring their own vehicle and work at their own time and are paid based on their time commitment. This variability requires monitoring, sophisticated algorithms, good incentives, competitive pricing to passengers, etc. which is also common in other gig economy jobs. In most cases, the analytics models that will be built for one gig economy can be tweaked to fit another one as well.&lt;/p&gt;
&lt;p&gt;Let&amp;rsquo;s look at a few components of Ride-hailing that will be relevant for how we frame our models and the data we use.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;For this post, &amp;ldquo;passengers&amp;rdquo; are referred to as service requesters/receivers and &amp;ldquo;drivers&amp;rdquo; are referred to as service providers.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;components-of-the-problem&#34;&gt;Components of the problem&lt;/h2&gt;
&lt;hr&gt;
&lt;h3 id=&#34;balancing-act-supply-and-demand-and-chicken-and-egg-problem&#34;&gt;Balancing act: Supply and Demand, and Chicken and Egg Problem&lt;/h3&gt;
&lt;p&gt;There is a balancing act that all of these ride-sharing platforms need to perform to be efficient. A healthy ratio between driver and passenger (to go more granular, for a segment of geographic area at a given time) is very important.  The balancing act is even crucial when a ride-hailing service decides to introduce itself to a new city (especially one that is new to ride-hailing).&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;If an area has more drivers than demand from passengers, the drivers might not get ride requests causing them to lose interest and find a different job or move to a different competition.&lt;/li&gt;
&lt;li&gt;If an area has more passengers than a supply of drivers, the passengers might not get their ride requests accepted causing them to move onto another (direct/indirect) competition.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;From an analytics perspective, this is a difficult problem to solve. However, good analytics can also be a competitive advantage here.&lt;/p&gt;
&lt;h3 id=&#34;pricing&#34;&gt;Pricing&lt;/h3&gt;
&lt;p&gt;Pricing is a by-product of the balancing act described above. The pricing must be competitive enough to lure the supply and the demand pool. The driver should feel like the pricing justifies the time, effort, and resources supplied. The passenger should feel the amount paid for the service justifies the service received.&lt;/p&gt;
&lt;p&gt;Few ride-hailing services opt-out for transparent and fixed payment (i.e the price is only dictated by the distance to destination), while some have complex pricing strategies to stand out, lure passengers or drivers, and manage supply and demand effectively.&lt;/p&gt;
&lt;h3 id=&#34;dynamic-pricing&#34;&gt;Dynamic Pricing&lt;/h3&gt;
&lt;p&gt;Some ride-hailing services implement dynamic pricing as a way to balance the chicken and egg problem described above. This is a large-scale, complex analytics problem involving several variables. Additionally, driver bonuses, discounts, and referrals might constitute the pricing strategy as well.&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://thumbor.forbes.com/thumbor/711x274/https://blogs-images.forbes.com/nicolemartin1/files/2019/03/dynamic-pricing.jpg?width=960&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Credit: Forbes&lt;/p&gt;
&lt;h3 id=&#34;competition-direct-and-indirect&#34;&gt;Competition (Direct and Indirect)&lt;/h3&gt;
&lt;h4 id=&#34;direct-competition-passenger&#34;&gt;Direct Competition (Passenger)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;other ride hailing services&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;direct-competition-driver&#34;&gt;Direct Competition (Driver)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;other ride-hailing services&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;indirect-competition-passenger&#34;&gt;Indirect Competition (Passenger)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;public transportation&lt;/li&gt;
&lt;li&gt;taxi/cab&lt;/li&gt;
&lt;li&gt;etc.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;indirect-competition-driver&#34;&gt;Indirect Competition (Driver)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;other employment opportunities&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://thumbor.forbes.com/thumbor/fit-in/1200x0/filters%3Aformat%28jpg%29/https%3A%2F%2Fblogs-images.forbes.com%2Fliyanchen%2Ffiles%2F2015%2F09%2F0908_uber-map2_2000-1940x1487.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Credit: Forbes&lt;/p&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;descriptive-analysis&#34;&gt;Descriptive analysis&lt;/h2&gt;
&lt;p&gt;Before we build complex models, it is essential to understand how the business/service is performing. These descriptive analyses will lay the foundation for us when we build complex and combined models later on.&lt;/p&gt;
&lt;h3 id=&#34;ride-completioncancellation-rate&#34;&gt;Ride Completion/Cancellation rate&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the ride completion rate?&lt;/li&gt;
&lt;li&gt;To be more granular, what is the ride completion rate at a geographic segment of the city at a particular time?&lt;/li&gt;
&lt;li&gt;What is the ride cancellation rate?&lt;/li&gt;
&lt;li&gt;Similar to before, what is the ride cancellation rate at a geographic segment of the city at a particular time?&lt;/li&gt;
&lt;li&gt;Why do passengers cancel rides?&lt;/li&gt;
&lt;li&gt;Is cancellation more prominent in one area compared to the other?&lt;/li&gt;
&lt;li&gt;Is this dependent on the time of the day?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;passenger_id&lt;/li&gt;
&lt;li&gt;driver_id&lt;/li&gt;
&lt;li&gt;latitude (pickup, drop)&lt;/li&gt;
&lt;li&gt;longitude (pickup, drop)&lt;/li&gt;
&lt;li&gt;timestamps (requested, accepted, picked up, dropped, canceled)&lt;/li&gt;
&lt;li&gt;completion_status&lt;/li&gt;
&lt;li&gt;cancellation_reason&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;late-arrival-rate&#34;&gt;Late arrival rate&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the late arrival rate?&lt;/li&gt;
&lt;li&gt;what is the late arrival rate at a geographic segment of the city at a particular time?&lt;/li&gt;
&lt;li&gt;Is the late arrival rate prominent for some time of the day or for a particular geographical area?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;passenger_id&lt;/li&gt;
&lt;li&gt;driver_id&lt;/li&gt;
&lt;li&gt;latitude (pickup, drop)&lt;/li&gt;
&lt;li&gt;longitude (pickup, drop)&lt;/li&gt;
&lt;li&gt;timestamps (requested, accepted, picked up, dropped, canceled)&lt;/li&gt;
&lt;li&gt;completion_status&lt;/li&gt;
&lt;li&gt;cancellation_reason&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;activation-acquisition-retention-referral-revenue&#34;&gt;Activation, Acquisition, Retention, Referral, Revenue&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What does the pirate metric funnel look like?&lt;/li&gt;
&lt;li&gt;Is there a specific area where the business should focus to improve business/efficiency?&lt;/li&gt;
&lt;li&gt;Is the funnel leaking somewhere?&lt;/li&gt;
&lt;li&gt;What is the passenger/driver churn rate?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;passenger_id/driver_id&lt;/li&gt;
&lt;li&gt;timestamps (created_date, last_ride_date)&lt;/li&gt;
&lt;li&gt;total_amount_spent_on_platform / total_money_made&lt;/li&gt;
&lt;li&gt;total_rides&lt;/li&gt;
&lt;li&gt;num_of_referrals&lt;/li&gt;
&lt;li&gt;acquisition_channel&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&#34;https://hygger.io/wp-content/uploads/2018/01/Main-EN.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;p&gt;Credit: hygger.io&lt;/p&gt;
&lt;h3 id=&#34;channels&#34;&gt;Channels&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the acquisition rate from different marketing channels for drivers or for passengers?&lt;/li&gt;
&lt;li&gt;What marketing channel is more apt/effective for different demography/user segments?&lt;/li&gt;
&lt;li&gt;Can we use the multi-arm bandits model to identify a balance between exploration and exploitation to test on different channels?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;passenger_id/driver_id&lt;/li&gt;
&lt;li&gt;timestamps (created_date)&lt;/li&gt;
&lt;li&gt;acquisition_channel&lt;/li&gt;
&lt;li&gt;total_amount_spent_on_platform / total_money_made&lt;/li&gt;
&lt;li&gt;passenger/driver demographic information (age, gender, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;user-analysis&#34;&gt;User Analysis&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What does the demography (social, cultural, economic) of the driver look like?&lt;/li&gt;
&lt;li&gt;What does the demography (social, cultural, economic) of the passenger look like?&lt;/li&gt;
&lt;li&gt;What does the demography of the city look like?&lt;/li&gt;
&lt;li&gt;What does the demography of the segment that uses the service the most look like?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;passenger_id/driver_id&lt;/li&gt;
&lt;li&gt;timestamps (created_date)&lt;/li&gt;
&lt;li&gt;acquisition_channel&lt;/li&gt;
&lt;li&gt;total_amount_spent_on_platform / total_money_made&lt;/li&gt;
&lt;li&gt;passenger/driver/city demographic information (age, gender etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;driver-rankingdriver-performance&#34;&gt;Driver Ranking/Driver Performance&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;How is a driver performing? (this could be based on multiple factors including customer rating, and other factors)&lt;/li&gt;
&lt;li&gt;Based on the index for performance, what is the rank of a driver?&lt;/li&gt;
&lt;li&gt;What is the rank of a driver among a segment of drivers? (this will be useful for priority queue for driver dispatching)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;driver_id&lt;/li&gt;
&lt;li&gt;timestamps&lt;/li&gt;
&lt;li&gt;average_rating&lt;/li&gt;
&lt;li&gt;rides_complete_rate&lt;/li&gt;
&lt;li&gt;last_ride_date&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;predictive-analysis&#34;&gt;Predictive analysis&lt;/h2&gt;
&lt;p&gt;If we are looking to make the system more efficient, it is also very important to understand what the future holds.&lt;/p&gt;
&lt;h3 id=&#34;growth-in-rides&#34;&gt;Growth in rides&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the number of expected daily rides next day/week/month/year?&lt;/li&gt;
&lt;li&gt;What is the expected revenue for the next day/week/month/year?&lt;/li&gt;
&lt;li&gt;Is there a daily/weekly/monthly seasonality?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;timestamp (daily)&lt;/li&gt;
&lt;li&gt;num_of_ride (completed rides or ride requests)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;passenger-growth&#34;&gt;Passenger growth&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the number of expected passenger growth next day/week/month/year?&lt;/li&gt;
&lt;li&gt;Is there a daily/weekly/monthly seasonality?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;timestamp (daily)&lt;/li&gt;
&lt;li&gt;num_of_unique_passengers (acquisition or ride request)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;driver-growth&#34;&gt;Driver growth&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the number of expected driver growth next day/week/month/year?&lt;/li&gt;
&lt;li&gt;Is there a daily/weekly/monthly seasonality?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;timestamp (daily)&lt;/li&gt;
&lt;li&gt;num_of_unique_drivers (acquisition or ride request)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;churn-over-the-period-of-time&#34;&gt;Churn over the period of time&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;What is the expected churn in the next day/week/month/year?&lt;/li&gt;
&lt;li&gt;Is there a daily/weekly/monthly seasonality?&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;DATA&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;timestamp (passenger acquisition)&lt;/li&gt;
&lt;li&gt;passenger&amp;rsquo;s number of rides each month (grouped acquisition to present)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;br&gt;
&lt;h2 id=&#34;prescriptive-analysis&#34;&gt;Prescriptive analysis&lt;/h2&gt;
&lt;p&gt;Descriptive and Predictive analysis will help us move towards prescriptive analysis, especially for optimization models. These models will help the service provider in decision making, especially with regards to an increase in efficiency for drivers and passengers.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ratio-of-drivers-to-passengers&#34;&gt;Ratio of drivers to passengers&lt;/h3&gt;
&lt;h4 id=&#34;what-is-the-ideal-ratio-of-the-passenger-to-the-driver-to-maximize-rides-completion-rate&#34;&gt;What is the ideal ratio of the passenger to the driver to maximize rides completion rate?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Given&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Voronoi clustering for geographic indexing based on geographic hotspots (other indexing methods are more efficient like h3 developed by Uber, but Voronoi can be used to build something similar as well.)&lt;/li&gt;
&lt;li&gt;rides data (requested, canceled, completed)&lt;/li&gt;
&lt;li&gt;passenger data (raw data and data after descriptive analysis performed: Pirate metrics etc.)&lt;/li&gt;
&lt;li&gt;driver data&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Optimization
&lt;ul&gt;
&lt;li&gt;with constraints: num_of_rides should be greater than a threshold (comes from future rides data)&lt;/li&gt;
&lt;li&gt;with objective functions: maximize rides completion rate for each geographic segment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;to find an optimal driver to passenger ratio&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Regression (or logistic regression if we only care about a healthy/unhealthy ratio) can also be used to do something similar as well.&lt;/li&gt;
&lt;li&gt;Additionally, the result from the model can also be used to model advertisement campaigns for the future if we find the number of driver or passenger (in a particular geographic area) need to be increased for a stable ratio.&lt;/li&gt;
&lt;li&gt;This is an important indicator because it allows the service provider to focus on growth while keeping this indicator at a healthy level.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;dynamic-pricing-1&#34;&gt;Dynamic pricing&lt;/h3&gt;
&lt;h4 id=&#34;what-should-the-dynamicsurge-pricing-be-at-a-given-time&#34;&gt;What should the dynamic/surge pricing be at a given time?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Given&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;ratio of the driver to passenger&lt;/li&gt;
&lt;li&gt;paying capacity of passengers (based on descriptive analysis of users, useful for capping at some multiplier so that it does not go wild)&lt;/li&gt;
&lt;li&gt;number of requests in the queue in a geographic segment&lt;/li&gt;
&lt;li&gt;competition surge at the moment&lt;/li&gt;
&lt;li&gt;number of requests completed in the geographic segment (and neighboring segment) in last x minutes (arbitrary but can be defined by waiting for time analysis from descriptive analysis)&lt;/li&gt;
&lt;li&gt;geographic location information (grid-based on Voronoi for the availability of drivers in other cells)&lt;/li&gt;
&lt;li&gt;number of drivers that will be free (complete a ride soon or are predicted to come online soon) in the grid or neighboring grids&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Linear regression&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;to find ideal dynamic pricing multiplier&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Notes&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The cap might/might not be necessary, and that might be another analytics problem altogether. There have been some cases where a natural disaster/terrorist attack increased surge multiplier to an exorbitant number causing massive backlash.&lt;/li&gt;
&lt;li&gt;grid above refers to one unit of Voronoi based geographic segmentation&lt;/li&gt;
&lt;li&gt;It is necessary to study the correlation of some of the predictors mentioned above.&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3 id=&#34;ride-dispatching&#34;&gt;Ride Dispatching&lt;/h3&gt;
&lt;h4 id=&#34;what-is-a-robust-ride-dispatching-mechanism-that-will-increase-passengers-and-drivers&#34;&gt;What is a robust ride dispatching mechanism that will increase passengers and drivers?&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Given&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Drivers in Geographic Grid (and neighboring Grid)&lt;/li&gt;
&lt;li&gt;Driver Rating/Driver Ranking&lt;/li&gt;
&lt;li&gt;Geographic Grid&lt;/li&gt;
&lt;li&gt;Pickup/Drop location (distance and Grid)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Use&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;Optimization
&lt;ul&gt;
&lt;li&gt;with constraints: the probability of each driver getting ride should be close to 1, waiting time should be less than some threshold for the request to be accepted  or not accepted (which comes from descriptive analysis), the time between request dispatching (time window a driver gets before the request is passed on to a different driver, also comes from descriptive analysis) should be equal to the acceptable waiting time divided by some constant (integer)&lt;/li&gt;
&lt;li&gt;with objective functions: maximize rides completion rate for each geographic segment&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;** Notes **&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Queuing models can also be here to identify correct values for the dispatching system (waiting time, dynamic geographic grid, etc.). However, there is a need to check the distribution of different events (booking created, booking accepted, waiting time, etc.)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;It seems analytics is extremely relevant in all aspects of ride-hailing. In this project, I merely covered a few use cases, with one or two relevant models. Even with this brief exploration, I can conclude that analytics can lead to better outcomes for both drivers and passengers.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>