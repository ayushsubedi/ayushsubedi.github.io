[{"categories":null,"contents":"Data Scientist, R\u0026amp;D and Mathematician  ayush.subedi@gmail.com | 9860909101\n  Eight years experience in R\u0026amp;D and data science A penchant for solving unstructured and non-standard mathematical problems Researcher, architect, and developer with a product and user mindset Passionate about mentoring junior team members Technical leader fostering the significance of research in software and market Attentive self-starter, great communicator, and personally empowered  Skills / Tools  Languages – Python, Java, R, JavaScript, Bash Databases – MySQL, SQLite, MongoDB, PostgreSQL, Firebase, Realm Data Viz – D3.js, Tableau, Google Data Studio, Plotly, Highcharts, Seaborn, Bokeh Data Analysis – Python data analysis stack (numpy, pandas, matplotlib) Machine Learning – Scikit-learn, FB Prophet, Keras, Tensorflow, PyTorch Framework – Flask, Fast API  Education Loras College, Dubuque-IA, USA\nB.S. in Computer Science\nB.S. in Mathematics\nCumulative GPA: 3.8402\nAugust 2013\nExperience Moonlit Solutions, Nepal\nData Scientist, Tech Lead, Cofounder, June 2019 – Present\nWorld Bank, Nepal\nData Science Consultant, June 2019 – Present\nBritish College, Nepal\nVisiting Lecturer, Data Science, Sept 2019 – Present\nISMT College, Nepal\nVisiting Lecturer, Data Structures and Algorithms, Feb 2019 – Sept 2019\nTootle, Nepal\nChief Technology Officer, Chief Data Scientist, Mar 2016 – Oct 2018\nThree60 Consulting, Nepal\nSenior R\u0026amp;D Engineer, Team Lead, Android Developer, Oct 2013 – May 2016\nPublications Use of ICT in Classrooms in Nepal; A study of Student-Centered Learning using ICT\nSKIMA 2015 December 16, 2015 (Publication link)\n","date":"2020-09-05T17:12:41+05:45","permalink":"https://subedi.ml/about/","section":"","tags":null,"title":"Resume"},{"categories":null,"contents":"The Du Compiler: For our Computer Science capstone project, we take on the beast - building a compiler from scratch. We had about three months to do it but we really had no clue of what we were doing for the first month and a half. Although we knew plenty of what there was to know about compilers in theory, we soon realized that building one from scratch was not going to be easy. We started with baby steps, and by the time the project was due, we were taking giant leaps (we had no other option). In the end, it turned out to be a reasonably fine compiler and an excellent experience. During these three months, I had the best and the worst experiences of my academic life. Therefore, this project is really special.\nSince this project belongs to two other people also, I won\u0026rsquo;t be posting any source code. This post will just have some example code for Du-Compiler.\nFinally, for anyone looking for a reasonably challenging senior projects, I would strongly encourage building a compiler. I say this for couple of reasons. First of all, it changes the way we look at code. It gives a better understanding of what exactly happens when the compile button is hit. In another words, it makes you aware of what is going on internally. Secondly, it involves learning/relearning several Computer Science topics such as regular expressions, hash table, data-structures, tree traversals, assembly level programming etc. It also involves A LOT of coding. When it all pans out, you are going to love what you have in your skill set.\nExamples //Hello World duhawk helloworld{ duPrint(%Hello World%); } //Simple Addition duhawk simpleAdd{ int a; a=5; int b; b = a + 5; duPrint b; } //Result: 10 //Simple Pattern duhawk test{ int i; i=1; int j; j=1; while (i\u0026lt;=10){ j=1; while (j\u0026lt;=i){ duPrint(%*%); j=j + 1; } duPrintln(%%); i= i + 1; } } /* Result * ** *** **** ***** ****** ******* ******** ********* ********** */ duhawk test{ int c; int d; duPrint (%Multiplication table of: %); duInput a; duPrint (%upto: %); duInput b; for (c=1;c\u0026lt;=b;c=c + 1){ duPrint a; duPrint (% X %); duPrint c; duPrint (% = %); d = a*c; duPrintln d; } } /* Input for a = 19 Input for b = 15 Result: Multiplication table of: 19 upto: 15 19 X 1 = 19 19 X 2 = 38 19 X 3 = 57 19 X 4 = 76 19 X 5 = 95 19 X 6 = 114 19 X 7 = 133 19 X 8 = 152 19 X 9 = 171 19 X 10 = 190 19 X 11 = 209 19 X 12 = 228 19 X 13 = 247 19 X 14 = 266 19 X 15 = 285 */ ","date":"2013-09-05T17:12:41+05:45","permalink":"https://subedi.ml/posts/ducompiler/","section":"posts","tags":["compiler","java","capstone"],"title":"Compiler from Scratch"},{"categories":null,"contents":"The Faro Shuffle:  A Faro shuffle is probably one of the most intricate skills in an elite magician\u0026rsquo;s arsenal. Although it\u0026rsquo;s simple in concept, it is extremely difficult to perform and it typically needs years and years of practice. The idea of a shuffle is to randomize the cards, and since a typical shuffle is sloppy, that is usually true. However, a Faro shuffle is not random at all. In a perfect shuffle or a Faro shuffle the cards are divided exactly in half (top and bottom) and then interspersed alternately. Twenty one consecutive (out) Faro shuffles for a 50-card deck. However, it only takes eight consecutive Faro shuffles to bring a 52-card deck back to its original order. Interesting. Java: If the number of cards in the deck is 12,\npublic class outFaro { public static void main(String[] args) { // the number of card in the deck int numberofcardindeck = 12; // creating an array of cards int[] deck = new int[numberofcardindeck]; // printing the order of cards in original deck System.out.println(\u0026quot;Original deck\u0026quot;); for (int i = 0; i \u0026lt; numberofcardindeck; i++) { deck[i] = i + 1; System.out.print(deck[i] + \u0026quot; \u0026quot;); } System.out.println(); // dividing the cards in half int[] firsthalfdeck = new int[numberofcardindeck / 2]; int[] secondhalfdeck = new int[numberofcardindeck / 2]; // performing a (out) Faro shuffle for (int Faro = 1; Faro \u0026lt;= 50; Faro++) { for (int i = 0; i \u0026lt; numberofcardindeck / 2; i++) { firsthalfdeck[i] = deck[i]; secondhalfdeck[i] = deck[i + (numberofcardindeck / 2)]; } for (int i = 0; i \u0026lt; numberofcardindeck / 2; i++) { deck[2 * i] = firsthalfdeck[i]; deck[2 * i + 1] = secondhalfdeck[i]; } System.out.println(); System.out.println(\u0026quot;Order under Faro Shuffle: \u0026quot; + Faro); for (int i = 0; i \u0026lt; numberofcardindeck; i++) { System.out.print(deck[i] + \u0026quot; \u0026quot;); } // done when the second card comes back to its original position if (deck[1] == 2) { break; } } } }  Result:\nOriginal deck 1 2 3 4 5 6 7 8 9 10 11 12 Order under Faro Shuffle: 1 1 7 2 8 3 9 4 10 5 11 6 12 Order under Faro Shuffle: 2 1 4 7 10 2 5 8 11 3 6 9 12 Order under Faro Shuffle: 3 1 8 4 11 7 3 10 6 2 9 5 12 Order under Faro Shuffle: 4 1 10 8 6 4 2 11 9 7 5 3 12 Order under Faro Shuffle: 5 1 11 10 9 8 7 6 5 4 3 2 12 Order under Faro Shuffle: 6 1 6 11 5 10 4 9 3 8 2 7 12 Order under Faro Shuffle: 7 1 9 6 3 11 8 5 2 10 7 4 12 Order under Faro Shuffle: 8 1 5 9 2 6 10 3 7 11 4 8 12 Order under Faro Shuffle: 9 1 3 5 7 9 11 2 4 6 8 10 12 Order under Faro Shuffle: 10 1 2 3 4 5 6 7 8 9 10 11 12  After 10 out-Faro shuffles, the card returns to its original permutation. Therefore, 10 is the order of the permutation.\nThe table below shows number of cards in a deck and the number of out-Faro shuffles required to bring it back to its original permutation.\nThe definition of permutation and permutation group:\n“A permutation of a set A is a function from A to A that is both one-to-one and onto. A permutation group of a set A is a set of permutations of A that forms a group under function composition.”\nA Faro Shuffle is one-to-one and onto. At any frequency of the shuffle, every index (1-n) will have a unique card. Also, for every card, there is a unique index regardless of the frequency of the shuffle. The permutation for every “Number of cards” can be thought as a group under the operation - FaroShuffle. Also, since “Number of Faro Shuffles” returns us back to the original permutation, we can establish it as the order of the permutation group.\nTheorem: The order of a permutation of a finite set written in disjoint cycle form is the least common multiple of the lengths of the cycles.The order of a permutation of a finite set written in disjoint cycle form is the least common multiple of the lengths of the cycles.\nThis is one of the most important Group Theory Theorems. Let us consider a 52-card deck to demonstrate this. From the Java code, the order is 8 when n is 52. Instead of looking at disjoint cycle form of the permutation to figure out the order of each element, we can also look at every permutation the original permutation has been to before returning to the original permutation. For n = 52, the table below shows all the permutations.\nFrom the table above, order of 1 and 52 = 1, order of 18 and 35 = 2 and order of rest of the elements = 8 The L.C.M (1,2,8) = 8 is the order of the group according to the Theorem. This is also what we got from the Java code.\nConjectures / Proofs:\nIn-Faro and Out-Faro In an out-Faro shuffle, the top card from first half of the deck always remains on top. In an in-Faro shuffle, the top card from second half will be the new top card of the new shuffled deck.\nSince I did not have a deck of card with me, and I was bored, I wrote a very simple Android app to demonstrate in and out shuffle.\nGenerating a random deck with 4 cards. Notice that the Eight of Hearts is on top.\nOut-Faro 1: Eight of Hearts is on top.\nOut-Faro 2: Eight of Hearts is still on top and the deck is back in its original permutation. Therefore, order = 2.\nIn-Faro 1: Using the same deck, Eight of Hearts is no longer on top.\nIn-Faro 2: Again\u0026hellip;\nIn-Faro 3:\nIn-Faro 4: Back to its original order. Order = 4.\nMore screenshots:\nAnother reason for writing the app was to see the connection between Binary Number System and Faro Shuffle. I read somewhere that magicians and gamblers use this for their advantage.\nConsider a random eight card deck.\nNow, the trick is, to send the Queen of Clubs to say for example, 7th position in the deck (6 cards on top of it), the gambler would perform two in-Faros and one out-Faro. 6 in binary is 110; so, for digit 1, the magician would perform an in-Faro and for 0, an out-Faro.\n1st in-Faro:\n2nd in-Faro:\nout-Faro:\nQueen of Clubs is now in the 7th position. Also, its really interesting that this works irrespective of the number of cards in the deck.\nI also found that the order of (2n+2) out-Faro shuffle is equal to the order of (2n) in-Faro shuffles.\nI find that pretty interesting and I do not really see that to be obvious. It also implies that for no 2n, In-Faro=Out-Faro (I think). I will be investigating on these more later.\n\n","date":"2012-12-05T17:12:41+05:45","permalink":"https://subedi.ml/posts/faro_shuffle/","section":"posts","tags":["faro","java","group theory"],"title":"The Faro Shuffle"},{"categories":null,"contents":"Area of the Mandelbrot Set:  The area of the Mandelbrot Set The Mandelbrot set is a fractal (illustrates self-similarity). The set is obtained from the quadratic recurrence equation,\nwith\n, where points\nin the complex plane for which the orbit of\ndoes not tend to infinity are in the set. The Mandelbrot set is a compact set, contained in the closed disk of radius 2 around the origin. Since it is contained in a disk of known area, it is possible to approximate the area of the Mandelbrot Set\u0026rsquo;s using Monte Carlo method.\n Java: Since Java does not inherently understand complex numbers, a \u0026ldquo;real\u0026rdquo; approach will be applied to perform the quadratic recurrence equation,\nFirst, as shown in the figure above, inscribe the disk in a square of length 4 units. Let\nrepresent the coordinate along x-axis (real) and\nrepresent the coordinate along y axis. Now set\nand\n, where\nand\nare randomly generated real numbers from [-2, 2]. Basically, the\nand\ncoordinates are being duplicated at this step to preserve the point\n. Next, iteratively compute the following from\n(for programming purposes, choose a large Dwell Limit). Simultaneously, check if\n. If yes, increase count (not in the set) by 1 and get out of the loop (since all points should be contained in the disk).\nCompute the ratio of number of points that are in the set to total number of points used. Then multiply the area of square (16 units square) to get the approximate are of the Mandelbrot set.\nJava Code:\nimport java.util.Date; import java.util.Random; public class MandelbrotArea { public static int mcRep = 5000; public static int dwellLimit = 2048; /** * @return random double in [-2,2] */ public static double random() { return (new Random().nextDouble() * 4) - 2; } /** * @param r: real part of the complex number * @param s: imaginary part of the complex number * @return */ public static boolean isMandelbrotSet(double r, double s) { double a = r, b = s, temp; // Iterative function for (int j = 1; j \u0026lt;= dwellLimit; j++) { temp = a; a = Math.pow(a, 2) - Math.pow(b, 2) + r; b = (2 * temp * b) + s; if (Math.pow(a, 2) + Math.pow(b, 2) \u0026gt; 4) { return false; } } return true; } public static void main(String[] args) { long startTime = new Date().getTime(); long count = 0; for (int i = 0; i \u0026lt;= mcRep; i++) { if (isMandelbrotSet(random(), random())) { count++; } } System.out.println(\u0026quot;Input -\u0026gt; DwellLimit: \u0026quot; + dwellLimit + \u0026quot;, McRep: \u0026quot; + mcRep); System.out.println(\u0026quot;Area: \u0026quot; + ((double) (count * 16)) / mcRep); System.out.println(\u0026quot;Execution time: \u0026quot; + (new Date().getTime() - startTime) + \u0026quot; ms\u0026quot;); } }  Result:\nInput -\u0026gt; DwellLimit: 2048, McRep: 5000 Area: 1.5136 Execution time: 389 ms  R\nmonte.Carlo \u0026lt;- 5000 x \u0026lt;- runif(monte.Carlo, -2, 2) y \u0026lt;- runif(monte.Carlo, -2, 2) list \u0026lt;- numeric(monte.Carlo) for (j in 1:monte.Carlo){ list[j] \u0026lt;- if (inmandelbrotset(complex(real = x[j], imaginary = y[j]))) 1 else 0 } area\u0026lt;-mean(list)*16 # function that checks if a point E mandelbrot set inmandelbrotset \u0026lt;- function(c) { dwell.limit \u0026lt;- 2048 z \u0026lt;- 0 for (i in 1:dwell.limit) { z \u0026lt;- z ** 2 + c if (Mod(z) \u0026gt; 2) { return(FALSE) } } return(TRUE) }  ","date":"2012-11-02T10:02:41+05:45","permalink":"https://subedi.ml/posts/mandelbrot_area/","section":"posts","tags":["mandelbrot","java","monte carlo"],"title":"Area of the Mandelbrot Set"}]