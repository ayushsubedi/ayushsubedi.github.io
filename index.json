[{"categories":null,"contents":"Data Scientist, R\u0026amp;D and Mathematician  ayush.subedi@gmail.com | 9860909101\n  Eight years experience in R\u0026amp;D and data science A penchant for solving unstructured and non-standard mathematical problems Researcher, architect, and developer with a product and user mindset Passionate about mentoring junior team members Technical leader fostering the significance of research in software and market Attentive self-starter, great communicator, and personally empowered  Skills / Tools  Languages – Python, Java, R, JavaScript, Bash Databases – MySQL, SQLite, MongoDB, PostgreSQL, Firebase, Realm Data Viz – D3.js, Tableau, Google Data Studio, Plotly, Highcharts, Seaborn, Bokeh Data Analysis – Python data analysis stack (numpy, pandas, matplotlib) Machine Learning – Scikit-learn, FB Prophet, Keras, Tensorflow, PyTorch Framework – Flask, Fast API  Education Loras College, Dubuque-IA, USA\nB.S. in Computer Science\nB.S. in Mathematics\nCumulative GPA: 3.8402\nAugust 2013\nExperience Moonlit Solutions, Nepal\nData Scientist, Tech Lead, Cofounder, June 2019 – Present\nWorld Bank, Nepal\nData Science Consultant, June 2019 – Present\nBritish College, Nepal\nVisiting Lecturer, Data Science, Sept 2019 – Present\nISMT College, Nepal\nVisiting Lecturer, Data Structures and Algorithms, Feb 2019 – Sept 2019\nTootle, Nepal\nChief Technology Officer, Chief Data Scientist, Mar 2016 – Oct 2018\nThree60 Consulting, Nepal\nSenior R\u0026amp;D Engineer, Team Lead, Android Developer, Oct 2013 – May 2016\nPublications Use of ICT in Classrooms in Nepal; A study of Student-Centered Learning using ICT\nSKIMA 2015 December 16, 2015 (Publication link)\n","date":"2020-09-05T17:12:41+05:45","permalink":"https://subedi.ml/about/","section":"","tags":null,"title":"Resume"},{"categories":null,"contents":"A brief history of Tootle Hello World, When Tootle started, there were four of us. At the time, we were working on EdCrayon (Three60’s Education and Classroom Management System). The development of EdCrayon was pretty much complete and one of the better schools in town had been implementing it for a year. We were busy with building fewer last minute requirements such as Nepalese school standard digital report cards and student ranking systems. After those were done and the academic session ended, we were preparing for the next academic session and we were also in talks with several schools for implementation of EdCrayon.\nhttps://princihere.files.wordpress.com/2016/10/androiddevices.png\nHowever, because of earthquake of 2015, the school that were lined up decided to back out and use their EdCrayon allocated resources on repairing the infrastructure damages. We would come to work and not feel productive at all. Due to the sheer boredom at work, we started researching on several ideas including location based services. One of the very first ideas was to create an app that would allow users to track location of Sajha buses on Google Maps so that they could plan on leaving offices/homes by referencing estimated time of arrival provided by the app. Even though Sajha buses were comparatively convenient, the problem was that people had to wait for the buses, generally up to half an hour, since bus stops arrival timings were more or less random. We developed the prototype for a Sajha bus route but since Sajha bus did not show any interest we decided to move on to other ideas.\nMeanwhile, I was researching on asynchronous API calls for a pet project of mine. I had been trying to figure out the best way to sync client’s on-device offline database and off-device master database. In this process, one of the first things that I did was to look into creating my own implementation by syncing Android SQLite database with MySQL database. Up until this point, when ever client sync was required, I would simply clear out the content adapter’s list, remove all elements, get all elements from master server and refill the adapter. This allowed for easy implementation. However, even if nothing was changed in the client database, whenever the client hit the sync button or pulled to refresh, the process would get repeated. Basically the question I was trying to answer was, “Is it faster and less expensive to individually assess for updates by comparing updated_date and id or to simply truncate and refill?” During the research for this, I stumbled upon newer technologies that would allow setting up changes listeners on client’s devices to refresh the changed list without having to trigger an action to sync the data. Using this finding and our research from location based services, we felt comfortable tackling the idea for a ride sharing application from a technological perspective, and Tootle was born. Tootle was not Tootle from the very beginning. We continued our research on appropriate Business Models, Brand Positioning, Business Strategy, and Marketing and Delivery. Based on the changes in how we were going to position our brand in the market, we changed the product name from CabIO (digital cabs), KAR.ma (share your ride for karma), Bzuli (environmentally conscious ride sharing) and finally to Tootle (a fun way to travel without restricting the service to electric vehicles and only four wheeled vehicles). In the meantime, based on the Business Models and Brand Positioning, several elements of the app were also changed.\nAlthough the concept of ride sharing is not new, and several companies such as Uber, Lyft, Ola and Go-Jek have implemented it tremendously well, Tootle is different mainly due to three core elements. First of all, we let our partners decide if they want to take a ride, i.e, we introduced the idea of casual Tootle partners. For example, a partner A can decide to give rides throughout the day and make this his/her full time job or simply give rides that matches his/her travel itinerary. The technology is adjusted in such a way that a tootle ride requests are sent to several partners within a vicinity rather than just one partner. Unlike aforementioned companies, there are no penalties involved for not taking a ride. Secondly, albeit not completely by choice, we have realized that frugality invites creativity. At every step of technology development, we have had to strategize inexpensive yet effective ways to solve problems. Although we are still purely in development phase as of today, I believe we can really take pride in what we have accomplished given the resources. This is also reflective in the product. We were forced to think about minimizing data consumption (given the high data cost in Nepal) and poor internet infrastructure. Currently, on average, a particular ride for a partner in terms of data exhausts 1 MB while him/her being able to log in, select appropriate ride, complete the ride and get paid, while the backend collects ride information such as timestamps for actions and exact route followed. This costs him/her 50 Paisa which is approximately $0.005. Finally, last but not the least, the major difference comes in the form of technology adaptation, contextualization and more importantly, communication. Kathmandu is traditionally more or less a close-knit community where people prefer talking to people to garner a sense of confirmation and safely. Therefore, it was crucial to build a simple and clean UI that gets the job done and focus massively on developing technologies that provided real time ride statistics to our team at call center so that they could assist people giving and taking Tootle rides. Similarly, since digitization of payment was essential but Nepal is not ready for secure and realtime credit card transaction, apart from local third party digital wallet integration we also have QR top-ups. To summarize, although from the surface, Tootle is a ride sharing application like Uber, it has established its own identity via contextualization of the requirements of Nepali needs. This is apparent throughout the technology.\nTootle Today From our experience, we have realized that market drives technology and not the other way around. We have also realized that although technology is merely a facilitator, it can do wonders to solve problems and invoke habit changes if done correctly. Now, we have a multidisciplinary team of 15 striving to make Tootle technologies and services better each passing day with the goal of doing it correctly.\n","date":"2017-10-01T11:02:11+05:45","permalink":"https://subedi.ml/posts/tootle_history/","section":"posts","tags":["product","tootle"],"title":"A brief history of Tootle"},{"categories":null,"contents":"Link to Tootle Website\nTootle is a ride sharing service that matches bike riders and commuters. While the concept is not new, there are several contextualization factors that makes it unique. As research and development engineer and lead software developer, this was my biggest challenge to date and I learnt a lot of things. However, since we worked in a very small team, I occasionally came across problems related to branding, client relationship, marketing and overall B2C business model. This blog post will dive into those learnings rather than focus on technological implementations. To summarize the entire post, it is about my journey from a single dimensional software developer to a software developer who also understands project management, human resources, market, competition, branding and plethora of other factors that a software developer whose long term goal is to become a tech entrepreneur needs in their arsenal.\nStart small, www.rome.com was not built in a day This is trivial for most people, but not for me. There were times I was so focused on completing a task that I lost the bigger picture. Breaking down a task into smaller subtasks and solving them as soundly as possible is the key. Also, when you push yourself too hard, you miss small details that might have huge consequences in the future. Think scalability while solving little problems. Like Will Smith said, \u0026ldquo;You don\u0026rsquo;t set out to build a wall. You don\u0026rsquo;t say \u0026lsquo;I\u0026rsquo;m going to build the biggest, baddest, greatest wall that\u0026rsquo;s ever been built.\u0026rsquo; You don\u0026rsquo;t start there. You say, \u0026lsquo;I\u0026rsquo;m going to lay this brick as perfectly as a brick can be laid. You do that every single day. And soon you have a wall.\u0026rdquo; Also, Hofstadter\u0026rsquo;s law will come along to shatter all your to-do plans for the day. It\u0026rsquo;s just the way it is. Deal with it.\nDevelopment and design is an iterative, never ending process. It is not a sprint but a marathon. Seeking perfectionism hurts. First of all, there is no perfect code or design. There might be something that looks, feels and works great today, but it is never going to be perfect. You will always have to come back to that line of code, redesign that slider that looked great once upon a time and continuously update based on user feedback. Coding is a little of writing code and a lot of maintaining it. You are never really done. Project preplanning and risk management might help with not having to go back to drawing board again and again, but development and design is very much an agile process.\nHire people who love what they do and love learning Coworkers become your second family. During the course of Tootle development, I actually spent more time with my coworkers than my family. Fortunately, everyone involved with Tootle are very passionate, hard-working and motivated people who never shy from learning. Also, certain characteristics such as being ardent, an embodiment and advocate of the product, and hardworking are more important than being skillful. I was also on the hiring team and I made sure to look for these characteristics. After all, Leicester City won 2015-2016 Barclays Premier League primarily because of their team spirit.\nPrioritize what is important There will be a lot of bugs. Code related stuff aside, there will also be several things that need attention. However, time is limited. At times you could be in front of your computer debugging for hours and hours, but still the issue tracker list and crash reporting list will be full. Therefore it is necessary to prioritize based on impact level. Assessing impact of a particular task can be difficult. However, if you have an awesome team, it is just a matter of discussing from a business and technical point of view. Also distinguishing between bugs, enhancement, improvement proposal and task is very important.\nCommunication solves 95% of all problems Communication is the key. Often during the day, talk to coworkers about the problems that you are having. First of all, when you explain the problem to someone, you understand the problem better yourself. Secondly, you are also in sync with what problems everyone else is facing. Similarly, simply talking about work related problems, expressing how you feel about deadlines, doing risk analysis together, discussing business strategy together, communicating dissatisfactions etc. will help solve a lot of problems earlier. So, constantly take a break, look outside the window, get a glass of water and simply talk.\nStress can be a catalyst if applied properly This project was very much stressful. Retrospectively, it was supposed to be too because of its complexity. One of the things I really struggled with is handling stress. I have gotten better over the course of this project. However, I am still working on learning to change stress to a catalyst. I hope to become Arsene Wenger someday (giggles). However, I have learnt that if things don\u0026rsquo;t work tonight, you simply have to sleep over it. The freshness of morning solves a lot of problems.\nYou could also just watch SRK dance in Hosh na khud kahi josh\u0026hellip;.\nGo running in the morning, be healthy This one is self-explanatory. Run to remain stress free and healthy. I stopped running for a while because I was lazy. But, I was also lazy because I was not running.\nCompetition is good While reading The Personal MBA by Josh Kaufman, I realized that having market competition is actually advantageous. This concept was really counterintuitive to me previously. Competition is good because it implies higher probability of fulfillment of something known as the Iron Law of Market. It basically means that like you, other people have also seen the availability of the market you are targeting. Similarly, there is a lot to learn from your competition. Learning and applying the principles of game theory helps a lot too. Awesome tech implementation is second to client\u0026rsquo;s requirement You could spend weeks and months on awesome, flawless and amazing features that your clients don\u0026rsquo;t really care about or half an hour on simple features that makes all the difference to them. For example, adding a bitcoin as payment system would be cool, but allowing a female client to select a female driver makes the product secure and also adds marketing and advertising weight.\nBeta tests are really really really important You could sit hours upon hours, days upon days trying to find and fix all the problems. But, finding problems is more difficult once you know your product inside out. You are in a controlled office environment with fast internet, limited real test devices and a clear understanding of product workings. There is no way for you to find all the problems. The solution is to find real users to test, use and provide feedbacks. Canary tests and beta tests are therefore very important.\nJust because you like it, does not mean users are going to like it also You might absolutely love your product. However, it does not mean every user will like it also. Be prepared to get bad ratings. Also, they are not wrong to dislike something you adore so much.\nPrevious projects and keeping up to date with latest technologies help a lot I really believe this one is a biggie. Regardless of whether or not a product succeeds, it is always a stepping stone for future products. This product would not have been possible or would have been terribly difficult without Edcrayon, Edquake, and dozens of other location related prototype. When prototyping, research on newer stacks and practices.\nIn the end, revenue matters the most In the words of Josh Kaufman, Do not be a mercenary since dedication in craft, patience to find right market to be dedicated towards and consistency is required to eventually make money.\nAlso, do not be a crusader since you need money to pay the bills.\nWish us good luck with our tootle journey.\n","date":"2017-01-28T13:12:41+05:45","permalink":"https://subedi.ml/posts/tootle_learnings/","section":"posts","tags":["product","tootle"],"title":"Learnings from Tootle"},{"categories":null,"contents":" The objective of the game was to use texts, audios, videos, badges, quizzes, points, stories and characters to educate users on preparation for earthquake and decision making during and after earthquake.\nApplication Description\nBefore the game starts, a teaser video is played where an event of earthquake is shown inside a home scenario. The video is shown in order to reflect the importance of earthquake preparedness. The video can be skipped the next time as per the choice of the player.\nApplication Home Screen\nThe application home screen allows users to start a new game, resume from where they left off previously, change game settings such as sound and language settings and submit their score to leaderboards, and quit the application. It also displays current user name and character selection along with all the badges that the user has won.\nStarting a new game\nUpon starting a new game, a dialog appears where the user enter his/her name and selects a character. The user can choose two characters that of a boy or a girl in order to play the game. These characters will also act as protagonists in animated stories.\nBadges\nBadges are provided to users upon completion of a milestone or a level. The badges provides an incentive for the players and makes the game more engaging and interesting.\nPSA and Video Activities\nEngines have been setup to support audio and video activities.\nThe radio can be used as an informative element in the game. For example:\nA PSA for earthquake preparation informing about vital items one needs in their emergency backpack can be played in the radio.\nThe video platform can support a series of storytelling addressing to different type of circumstances and safety tips regarding the effects of earthquake. Nepali subtitles also appear on the bottom of each videos.\nDrag and Drop Activity\nEngines have been setup to support drag and drop activities.\nBased on this drag and drop engine we have developed relevant games. For example:\nPreparing a GoBag\nFollowing the PSA, the users are required to drag and drop items from a set of vital items (such as first aid kid) and useless items (such as toys) to their backpack. Since the backpack can only hold a certain number of items, the users will have to optimize for best preparation. Upon completion, the app lets the users know if their selection is correct.\nSimilarly, the app will let the users know if their selection was wise. In case of wrong selection, the app will also let the users know why their selection was incorrect. Unlike other quiz activities, the difference here is that the users will still be allowed to go back to change their answer. The rationale was to follow a formative teaching approach.\nQuiz Engines\nEngines have been setup to support quiz platform.\nQuizzes produces better organization of knowledge by helping the brain organize material in clusters to allow better retrieval. It also identifies gap in knowledge and lets people know what is learned and what is not.\nThe quiz engines supports quiz games which can be very informative. The answers chosen can also lead to some consequent information or videos later.\nThere are four different types of quiz questions.\n Grid Select True and False Multiple Choice Questions (3 Options) Multiple Choice Questions (4 Options)  The first two types of questions carry a marking rubric of 200 points. The user receives complete points if he/she answers it correctly in the first go. The point a user can collect from each quiz is reduced depending on the number of mistakes.The third question carry a marking rubric of 300 points and the fourth question carry a marking rubric of 400 points. Similarly, depending on the mistakes, the point is reduced. The result is displayed with additional tip information and graphics.\nExample 1: Grid Quiz Activity\nExample 2: Multiple Choice Quiz Activity (3 options)\nLeaderboards and Facebook sharing\nThe application will allow users to submit their points to a global leaderboards system. This will allow users to compete with other players.\n","date":"2016-10-22T04:01:02+05:45","permalink":"https://subedi.ml/posts/edquake/","section":"posts","tags":["android","product"],"title":"Edquake"},{"categories":null,"contents":"Edcrayon’s Universal Deployment Model, converts tablets or phones to a smart, self-paced, predictive learning environment. It packages the following features:\n Thousands of qualitative educational content that students can browse from and download for offline use. Gamified and engaging UI to make sure students love learning from the application. Serves as supplement to topics being taught in school or simply for self-study. Available in different languages to facilitate mother tongue learning. Learning materials is localized and contextualized too. Provides practice lessons and quizzes auto-graded by the application so that the students can work their way through the assessments as in self-paced learning. Features quiz engines that adapts to students previous knowledge on a particular subject material. If a student struggles with a specific type of problem the application will generate more questions of similar type. Provides performance charts and allows students to track their own performance. Facilitates discussion forums to allow students from different places to discuss and share ideas. The performance data will also be sent to regional or central data repository for analysis purposes. The data will help decision makers to facilitate better or different features and contents to ensure more productivity and performance.  Current challenges in education\n Delivery of published books to every part of the country has been a significant problem due to the expenses involved in publishing and also due to the lack of road infrastructure. Even in cases where books are delivered on a timely basis, it only facilitates traditional teacher-centered teaching pedagogy. Twenty first century education calls for individualized learning which cannot be achieved since published books are not tailored to learners specific needs. Not all students get the optimum learning value from text based materials alone. Several schools have a large teacher to student ratio. Teachers also invest a huge portion of their time on things like keeping comprehensive performance records of every student, preparing and keeping track of lesson plans, and various other administrative tasks. If a system aided the teachers with these mundane tasks, the time saved can instead be utilized for student teaching and classroom engagement. Individualized attention can be provided to the students even in classes where the ratio is high. Decision makers in schools do not have all the performance data of all students and/or teachers at all time. A quantitative analytical report of performance with historical data assists in decision making processes. Schools still follow standardized and summative assessment system. This is partially because the system is inherent in us. However, we believe that the main reason is simply logistical. Large student size, lack of formative assessment tools, lack of engines to create individualized assessment etc. are some contributors.  Use of technology in education can facilitate myriad of tools that help in solving the challenges. Edcrayon facilitates easy delivery of qualitative media contents, smart algorithms and/or modules that allow for individualized learning via tailored content pushing and group creation, self-paced learning, smart performance charts, and formative and summative assessment models.\nCurrently, private schools have benefitted from Edcrayon’s Classroom Deployment Model. This deployment model converts a traditional classroom environment to technology based, student-centered model. It packages the following features:\n Constitute all the elements of Universal Deployment Model with an addition to a guided learning and teaching environment. Replaces the traditional learning and teaching classroom environment to a student centered, formatively assessed, skill based, interactive learning and teaching environment. Rather than learning at their own pace, which has its own merits, this approach allows students to communicate and learn from teachers and other students in the classroom. Facilitates teachers with student performance charts. Allows teachers to assign tailored materials for more individualized learning approach. Facilitates formative and Inquiry based assessment through continuous feedbacks from teacher and other students. Performance data of students and teacher are available to decision makers. Government proposed Continuous Assessment System is implemented.  Makes it very easy to perform day to day tasks such as attendance, register keeping, etc.\nSome Screenshots of Android Application:\nSome Screenshots of Web Application:\nMy role of R\u0026amp;D engineer and Project Lead incorporated architecting overall logic and process flow of Administrative and TeacherUI consisting User, Content, Classroom, Health and Pedagogy Management System. I also designed and co-developed EdCrayon Android application incorporating offline services, interactive charts, formative pedagogy, quiz engines among other features. Additionally, I developed several database administrative tools, wrote several crons and selenium test scripts, and managed multiple school servers. Similarly, I also trained and mentored junior programmers in programming methodologies and best practices. Additionally, I was also involved in training teachers, school-coordinators and school principal to use EdCrayon. Apart from my primary focus on technology, I also served as a core group member in defining and prioritizing technology investments and business objectives.\nPrototype samples: Sample 1 Sample 2 Sample 3\n","date":"2016-02-01T02:21:02+05:45","permalink":"https://subedi.ml/posts/edcrayon/","section":"posts","tags":["android","product"],"title":"Edcrayon"},{"categories":null,"contents":"It uses MPAndroidChart which allows users to scroll within the graphs too.\n","date":"2016-01-01T03:11:02+05:45","permalink":"https://subedi.ml/posts/etymology/","section":"posts","tags":["Android","etymology"],"title":"Etymology and Ngram"},{"categories":null,"contents":"Improving Literacy has been one of the biggest challenges faced by the developing world.\nUnited Nations underscored the importance of combating inequalities in education in its Sustainable Development Goals (Post 2015 Agenda) as the proposed SDG 4 suggests the international community to “Ensure inclusive and equitable quality education and promote lifelong learning opportunities for all by 2030”.\nIn Nepal, the literacy rate for the total population is 57.4 % which shows that the inequalities still persist (CIA World Factbook). Significant portion of the population have been deprived of learning opportunities due to various reasons including early marriage, gender inequalities, social and family pressure to engage into economic activities at an early age etc. Research also suggests that in developing countries, there is very low self esteem among people who are illiterates or semi literates.\nIn this digital world, they are even at greater disadvantage. Those with the least amount of schooling will find it increasingly more difficult to participate in the evolving knowledge-based societies, deepening the social divide (Reimers, 2000). There needs to be an innovative approach to match both the education and technological gap. Recent development in the mobile technology provides us with great opportunities to fill this gap.\nThe mobile devices offer both affordability and storage capacity which makes it possible to equip with different types of educational content. There are over 5 billion mobile subscribers worldwide today –an astounding number considering the world’s current population which is roughly 6.8 billion (ITU, 2010). The rapid proliferation of mobile technologies throughout the world has brought substantial attention to the potential to leverage the power of these new technologies to address decades old problems, including educational inequalities (see Keen and Mackintosh, 2001; Ling, 2004).\nProduct / Technology Concept\nThe ICT tool (Android application) for the training will have different components for learning, assessments, data-collection and data-analysis. The idea is to make the application interactive and to reflect a game-environment where users will be motivated by game elements such as unlocking levels (lessons) as they complete certain tasks. The lessons will be based on the UNESCO’s newly-literate book (Mathani) for Awadhi language (Part-2). However, certain levels from Part-1 will also be added as a means to bridge their previous knowledge.\nSome of the lessons that will be included for the pilot are as follows:\n Word formation Basic math (addition and subtraction) Paragraph reading Paragraph listening Word math Time/Calendar Filling forms, writing letters etc.  Some forms of assessments/practice lessons that will be included in the pilot are as follows:\n Android drawing canvas Multiple choice questions True/False questions Filling in the blanks Writing lessons  The following user data will be collected within the application with the assumption that every learner will have a personal device to work on:\n User information Level progression data Demographic data Application usage data Performance data Location data  The data can be synced in real-time if Internet connectivity is not an issue. However, in places where connectivity can be a problem, or it is expensive, an alternative approach where data is synced periodically can be utilized.\n","date":"2015-10-01T05:14:01+05:45","permalink":"https://subedi.ml/posts/neoliteracy/","section":"posts","tags":["Android"],"title":"Neo-literacy app concept"},{"categories":null,"contents":"I recently stumbled upon a customer loyalty measurement scale termed Net Promoter Scale (NPS in short) via a conversation with a businessy friend of mine who was researching on it. I was truly amazed by the simplicity yet brilliance of NPS. Moreover, this is ideal for someone like me who wants to get honest customer feedback without harassing them with poorly designed questionnaires regarding a product. The pith of NPS lies in the question:\n“How likely is it that you would recommend our company/product/service to a friend or colleague?”\nThose who respond with a score of 9-10 are called Promoters, and are considered likely to show positive behaviors like repeat purchase and positive referrals. Those who respond with a score of 0-6 are labeled Detractors, and they are believed to exhibit the negative behaviors like driving away from the brand, negative referrals. Responses of 7 and 8 are labeled Passives, and their behavior falls in the middle of Promoters and Detractors.\nThe NPS Calculation formula\n(Number of Promoters — Number of Detractors) / (Number of Respondents) x 100\nNPS ranges from -100 to 100 (inclusive).\nWith me doing the charting part and my friend doing the result implication and significance part we developed a simple NPS calculator app that takes total detractors, passives and promotors to output NPS. Refer to the screenshots below to identify what different NPS score signify.\n","date":"2015-04-04T04:01:02+05:45","permalink":"https://subedi.ml/posts/nps/","section":"posts","tags":["Android"],"title":"Net Promoter Scale (NPS)"},{"categories":null,"contents":" I had contributed as a debugger on Seeds of Empowerment\u0026rsquo;s Swahili Phonics application a while back. This blog post lists various test cases for Swahili Phonics Learning Application for identification of completed requirements and current issues. Thereafter, it also lists the problems that were solved.\n1. User interface and interaction\nThe application has great user interface. Since the majority of targeted users are young children, it is important to make learning fun. This application successfully does that. The only issue with the user interface is that it does not adapt to the full screen width.\nExpected screen:\nCurrent screen:\n2. Data collection\nThe application collects all sorts of data from the players and stores it locally in the user\u0026rsquo;s device. The players can re-login using their user-name and password and the application allows continuation from where they left before. The application also stores every hits and misses of a user. Although not currently implemented, the data can be used for analysis purposes to identify things like what set of phonetic sound players mostly struggle with.\n3. Algorithm\nAlthough the application provides a great framework for scalability, localization in different languages, and analytics there are few issues that we feel need some attention. We have been able to identify the following problems. We were not really sure if these problems were known since the realization came from analysis of the code rather than from the use of application. Therefore, we decided to list these problems with screen-shots so that it becomes more easier to understand.\nI) random number generation problem\nIn the current implementation, random numbers help generation of correct and incorrect answer. However, correct answer is always selected from the current level the player is at but incorrect answer set is generated from level 1 through current level. Because of this, although the options will have certain phoneme that are from previous level, they will never be the correct answer.\nSome examples:\nIf a user is at level 2, the correct option will never be from level 1. To generalize, if the user is at level n, the possible set of answers will only be from the phonemes allocated for that particular level n and not from any levels less than n.\nIn this case, the answer only be “bo”, “be” or “bi”. With progression of levels, it becomes more noticeable:\nHere the possible answer is only one (ie. 4). Also, with the progression of levels, the answers will most likely be the option that the user has not seen before. The game will not chose any phonemes as correct that were part of the option set in previous levels.\nII) the phonemes are always chosen from a statically defined list\nSince the game always refers to a single static list of phoneme for selecting correct and incorrect options, it does not adapt to re-test previous misses of a user.\nIII) chances of missing some phonetics because of dynamic array creation\nThe application generates a list during application runtime to check if all phonemes for a particular level have been tested. If a phoneme is tested twice in a level and the player chose the correct answer again, the stars are not increased because the generated list already has the phoneme. It was added to the list when the player answered correctly the first time around. This is a great implementation. However, there is also a small issue with this. Since the list is generated during runtime but the number of stars a player has in a particular level is stored and retrieved when the player re-logins, chances are, some phonemes are never tested.\nAn example, If Player A starts the game, and in Level 1 he/she successfully recognizes phonemes for {a, e, o, u}, the screen-shot would look something like this:\nWhen the player is playing the game, the game initializes an array and stores all the successful hits exactly once. The list has “a”, “e”, “o”, and “u” at this point. The player is promoted to another level when he/she has five stars.\nThe stars are increased if a phoneme can be added to a list (the condition being it does not already exist in the list). In this case, the stars will only be increased if the phonetic for “i” is tested and the player successfully answers that.\nBut, if the player decides to leave the game at this point to continue at another time, the array that stored all previous successful hits will be reset. Although he/she will still have 4 stars, now all it takes to move to another level is to identify the first phoneme put by the game. Because of this issue, the might progress to next level without having to identify phoneme for “i”.\n4. Adaptability\nThis feature is currently missing because it depends on algorithm design. Once the issues are resolved in that part, the next step would be to work on adapting the levels to test users on previously missed phonetics.\n5. Report Generation\nAlthough the application successfully collects useful data, the data is currently not being utilized for analysis.\nIdentified solutions for aforementioned bugs:\nThe solutions have already been implemented in the application. Currently, only algorithm specific problems have been solved. The application still needs additional design and game elements to make it more interactive.\n","date":"2015-02-02T04:04:01+05:45","permalink":"https://subedi.ml/posts/swahili/","section":"posts","tags":["Android"],"title":"Swahili Phonics App with Stanford University"},{"categories":null,"contents":" The Zorganian Republic has some very strange customs. Couples only wish to have female children as only females can inherit the family\u0026rsquo;s wealth, so if they have a male child they keep having more children until they have a girl. If they have a girl, they stop having children. What is the ratio of girls to boys in Zorgania?\nThe ratio of girls to boys in Zorgania is 1:1. This might be a little counter-intuitive at first. Here are some ways of tackling this problem. 1. Monte Carlo Simulation: Although, Monte Carlo simulation does not necessarily show why the result is 1:1, it is appropriate because of the very counter-intuitive nature of the problem. At the very least, it helps us see that the result is indeed 1:1. Therefore, this is a good start.\nThe following R code estimates the probability of a child being a boy in Zorgania.\ncouples \u0026lt;- 100000 boycount \u0026lt;- 0 for (i in 1:couples){ # 0: boy while (sample(c(0,1),1) == 0) { boycount=boycount+1 } } probability \u0026lt;- boycount/(couples+boycount)  Result:\n2. Understanding the question better: Here is another question: What is the probability of getting a tail in a fair coin toss, if all seven previous tosses resulted in heads? Since coin flips are independent events, the probability is still going to be 0.5. Similarly in this case, the child births are independent. It does not matter if the couples stop giving birth after they have a baby-girl. The expected value is unchanged.\nFor example, consider five couples: C1, C2, C3, C4 and C5. If B-\u0026gt; Boy and G-\u0026gt; Girl. Using R\u0026rsquo;s sample(). For C1: {B, G} For C2: {G} For C3: {B, B, G} For C4: {B, G} For C5: {G}\nNow, ignore the couples and only consider the children. The children are {B, G, G, B, B, G, B, G, G}. The only thing happening here is simply the generation of either a B or a G with equal probability for each generation. At this point, it is quite obvious that the part that has to do with \u0026ldquo;couple\u0026hellip;.\u0026rdquo; in the question is to mislead and confuse similar to the \u0026ldquo;previous seven tosses..\u0026rdquo; example that I mentioned in the beginning of 2.\n3. Counting:\nIf we start with 512 couples (hence 512 first borns), half of them are going to have a girl as their first. Those couples will stop having children. Among, the other half couples who had a son as their first child, half of them are going to have a girl as their second child and so on. At every step there is an equal numbers of boys and girls. Therefore, the expected ratio is 1:1.\n","date":"2014-04-18T09:13:12+05:45","permalink":"https://subedi.ml/posts/zorgania/","section":"posts","tags":["R","monte carlo","probability"],"title":"Republic of Zorgania"},{"categories":null,"contents":"The Du Compiler:  This is the naive/brute-force implementation of the Mandelbrot Set plotting. I just followed the algorithm.\n# Plotting the Mandelbrot Set # length of sequence for real and imaginary parts of complex numbers length \u0026lt;- 1000 # sequences for real and imaginary parts real = seq(-1.8,0.6, len=length) imaginary = seq(-1.2,1.2, len=length) result \u0026lt;- matrix(nrow = length, ncol = length) for (i in 1:length) { for (j in 1:length) { result[i,j]=inmandelbrotset(complex(real = real[i], imaginary = imaginary[j])) } } image(result, axes=FALSE) # function that checks if a point E mandelbrot set inmandelbrotset \u0026lt;- function(c) { dwell.limit \u0026lt;- 2048 z \u0026lt;- 0 for (i in 1:dwell.limit) { z \u0026lt;- z ** 2 + c if (Mod(z) \u0026gt; 2) { return(FALSE) } } return(TRUE) }  Adding colors: We now have a Boolean matrix that records if a point is in the Mandelbrot Set. Since the matrix can only have two values : true or false, thus far, we have only been able to plot read and white images. The next step is to add colors such that we get more information on when a particular point escapes the radius of 2. Again, this is the naive/brute force way of doing it.\n# Mandelbrot Plotting with colors length \u0026lt;- 1000 real = seq(-2.0,2.0, len=length) imaginary = seq(-2.0,2.0, len=length) result \u0026lt;- matrix(nrow = length, ncol = length) dwell.limit \u0026lt;- 512 for (i in 1:length) { for (j in 1:length) { z \u0026lt;- 0 c \u0026lt;-complex(real = real[i], imaginary = imaginary[j]) for (k in 1:dwell.limit) { z \u0026lt;- z ** 2 + c if (Mod(z) \u0026gt; 2) { result[i,j]=k break } } } } set.seed(2) image(result,breaks=0:dwell.limit ,col=c(1,sample(terrain.colors (dwell.limit-1,alpha = .8))),asp=1,ax=F)  and, just for the heck of it..\nASCII Mandelbrot Set using R (naive)\ns \u0026lt;- seq(-1.7,1.2, by =.1) a \u0026lt;- \u0026quot;\u0026quot; for (i in 1:length(s)) { for (j in 1:length(s)) { a\u0026lt;-cat(a,inmandelbrotset(complex(r = s[j], i = s[i]))) } a \u0026lt;- cat(a,\u0026quot;\\n\u0026quot;) }  Achieved by returning a \u0026quot; \u0026quot; or \u0026ldquo;#\u0026rdquo; instead of FALSE or TRUE from function \u0026ldquo;inmandelbrotset\u0026rdquo;. A better algorithm Utilizing R\u0026rsquo;s easy to use lists in implementation:\n# more efficient algorithm to plot the Mandelbrot set sequence \u0026lt;- seq(-2,2,len=1000) dwell.limit \u0026lt;- 200 # matrix of points to be iterated complex.matrix \u0026lt;- t((sapply(sequence,function(x)x+1i*sequence))) in.mandelbrot.index \u0026lt;- 1:length(complex.matrix) iter=z=array(0,dim(complex.matrix)) for(i in 1:dwell.limit){ # complex quadratic polynomial function for all points z[in.mandelbrot.index]=complex.matrix[in.mandelbrot.index]+z[in.mandelbrot.index]^2 # boolean matrix result=Mod(z[in.mandelbrot.index])\u0026lt;=2 # if result is false, store the iteration iter[in.mandelbrot.index[!result]]=i # save all the index where points are still in the mandelbrot in.mandelbrot.index=in.mandelbrot.index[result] } set.seed(19) image(iter,main=paste(\u0026quot;Iterations: \u0026quot;, i, sep=\u0026quot; \u0026quot;), breaks=0:dwell.limit ,col=c(1,sample(rainbow (dwell.limit-1,alpha = .8))),ax=F, asp=1)  Plotting the Julia set A little modification to the code above (red and white Mandelbrot) produces Julia Sets. The idea here is to set a constant C and send Z to the function instead of C.\nc \u0026lt;- complex(real=-0.1,imaginary=0.651) label \u0026lt;- toString(c) injulia \u0026lt;- function(z) { dwell.limit \u0026lt;- 128 for (i in 1:dwell.limit) { z \u0026lt;- z ** 2 + c if (Mod(z) \u0026gt; 2) { return(FALSE) } } return(TRUE) }  Adding colors: This is achieved by following the same process as above.\nSierpinski Gasket using Chaos game\n#### Chaos game for generation of Sierpinski Gasket # 1. Take 3 points in a plane to form a triangle, you need not draw it. # 2. Randomly select any point inside the triangle and consider that your current position. # 3. Randomly select any one of the 3 vertex points. # 4. Move half the distance from your current position to the selected vertex. # 5. Plot the current position. # 6. Repeat from step 3 plot.new() iterations \u0026lt;- 2000 vertices \u0026lt;- matrix(c(0,0,0.5,1,1,0),3,2, byrow=T) current.point \u0026lt;- c(0.5,0.5) random.vertex \u0026lt;- sample(1:3,iterations,replace=T) plot.result = matrix(nrow=iterations,ncol=2) for (i in 1:iterations){ current.point \u0026lt;- (current.point+vertices[random.vertex[i],])/2 plot.result[i,] \u0026lt;- current.point } points(plot.result,pch = 46)  Adding colors:\npoints(plot.result,pch = 46,col=c(13,3,41)[random.vertex])  ","date":"2014-04-15T17:12:41+05:45","permalink":"https://subedi.ml/posts/fractal_plots/","section":"posts","tags":["mandelbrot","R","viz"],"title":"Fractal Plots"},{"categories":null,"contents":"For quite some time now, my father and my uncle have been debating over the coordinates of their houses with respect to each others. Albeit barely 750 meters from each other, there is not much visible reference points or landmarks to figure it out accurately. The blame is on the molasses thick concrete jungle of Kathmandu valley. (Side-note: Kathmandu will soon be synonymous to the word asphyxiation). Although, I sincerely appreciate their curiosity, I think it is time to end this for once and for all.\nI have used photos of my sister (Ashma) and my cousin (Samip) as labels to the directions.\nThe app implements Canvas to \u0026ldquo;draw\u0026rdquo; the direction. The two GPS coordinates (obtained from Google Earth) were hard-coded into the program and Azimuth from orientation sensor was used to calculate the direction. Basically, it is a compass that points the direction from one house to the other instead of pointing North. Apart from this rather trivial implementation, the code can be modified to achieve some fun/interesting/useful developments. For instance, the direction of Mecca for Muslim prayers is one that comes to mind. Or, it could be modified into a bearing pointer app by using GPS data and some input EditTexts.\nCode Snippet onCreate\n protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mCustomDrawableView = new CustomDrawableView(this); setContentView(mCustomDrawableView); // Register the sensor listeners Resources res = getResources(); samip = BitmapFactory.decodeResource(res, R.drawable.samip); ashma = BitmapFactory.decodeResource(res, R.drawable.ashma); // Fill in correct latitude and longitude currentLoc.setLatitude(0.000000); currentLoc.setLongitude(0.00000); currentLoc.setAltitude(00); destinationLoc.setLatitude(0.00000); destinationLoc.setLongitude(0.0000); mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE); accelerometer = mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER); magnetometer = mSensorManager.getDefaultSensor(Sensor.TYPE_MAGNETIC_FIELD); }  Canvas\n Float azimuth; public Bitmap samip; public Bitmap ashma; public class CustomDrawableView extends View { Paint compassAxis = new Paint(); Paint compassCircle = new Paint(); Paint compasAarrow = new Paint(); public CustomDrawableView(Context context) { super(context); compassAxis.setColor(0xff00ff00); compassAxis.setStyle(Style.STROKE); compassAxis.setStrokeWidth(2); compassAxis.setAntiAlias(true); compassCircle.setColor(0xff000000); compassCircle.setStyle(Style.STROKE); compassCircle.setStrokeWidth(10); compassCircle.setAntiAlias(true); compasAarrow.setColor(0xff0000ff); compasAarrow.setStyle(Style.STROKE); compasAarrow.setStrokeWidth(3); compasAarrow.setAntiAlias(true); }; protected void onDraw(Canvas canvas) { int width = getWidth(), height = getHeight(); int centerx = width / 2, centery = height / 2; /* * Drawing the axis and circle Being symmetrical, these don't need * to be rotated */ // Axis canvas.drawLine(centerx, 0, centerx, height, compassAxis); canvas.drawLine(0, centery, width, centery, compassAxis); // Circle canvas.drawCircle(centerx, centery, 200, compassCircle); /* * since this was a pretty small scope app, magnetic north was not * changed to real north. See: \u0026quot;GeomagneticField\u0026quot; */ // Used Float instead of float for this check if (azimuth != null) { // Converting radians to degrees float temp = (float) Math.toDegrees(azimuth); float bearing = currentLoc.bearingTo(destinationLoc); float direction = temp - bearing; canvas.rotate(-direction, centerx, centery); } canvas.drawLine(centerx, centery - 200, centerx, centery, compasAarrow); canvas.drawBitmap(samip, centerx + 5, centery - 200, compassAxis); canvas.drawBitmap(ashma, centerx + 5, centery - 15, compassAxis); } }  Screenshots:\nAnd after some time wasting:\n","date":"2014-03-31T12:11:45+05:45","permalink":"https://subedi.ml/posts/thelostbrothers/","section":"posts","tags":["android"],"title":"The Lost Brothers"},{"categories":null,"contents":"Android+Arduino RC Car The previous attempt was in shambles due to the lack of proper products. This time, I got myself a Sainsmart L293D motor driver (actually a cloned version of the ever so popular Adafruit L293D driver) and a handy four wheel drive chassis. Hereupon, the only adjustment required was the use of analog pins as digital pins. This is the consequence of the motor driver using up all the digital pins and leaving no pins for the Bluetooth shield. I also hooked up the Arduino to a USB power bank.\nTools used: ~ Arduino Uno ~ 4WD Chassis ~ SainSmart motor driver (L293D) ~ Sunkee 30ft Bluetooth Module ~ Anker 15000 mAh power bank\nArduino\n//Project: Android RC Car //Author: Ayush Subedi #include \u0026lt;AFMotor.h\u0026gt; //import Adafruit Motor library #include \u0026lt;SoftwareSerial.h\u0026gt;// import the serial library SoftwareSerial newPorts(15, 17); // RX =15= A1, TX=17=A3 AF_DCMotor motor1(1, MOTOR12_1KHZ); // create motor #1, 1KHz pwm AF_DCMotor motor2(2, MOTOR12_1KHZ); // create motor #2, 1KHz pwm AF_DCMotor motor3(3, MOTOR34_1KHZ); // create motor #3, 1KHz pwm AF_DCMotor motor4(4, MOTOR34_1KHZ); // create motor #4, 1KHz pwm void setup() { newPorts.begin(9600); motor1.setSpeed(255); // set the speed to 200/255 motor2.setSpeed(255); // set the speed to 200/255 motor3.setSpeed(255); // set the speed to 200/255 motor4.setSpeed(255); // set the speed to 200/255 } void loop() { while (newPorts.available() \u0026gt; 0) { char ch = newPorts.read(); newPorts.println(newPorts.read()); executeReceivedCommand(ch); } } void executeReceivedCommand(char command) { switch (command) { //Forward case '0': motor1.run(FORWARD); motor2.run(FORWARD); motor3.run(FORWARD); motor4.run(FORWARD); break; //Reverse case '1': motor1.run(BACKWARD); motor2.run(BACKWARD); motor3.run(BACKWARD); motor4.run(BACKWARD); break; //Left : skid steering case '3': motor1.run(FORWARD); motor4.run(FORWARD); motor2.run(RELEASE); motor3.run(RELEASE); break; //Right : skid steering case '4': motor2.run(FORWARD); motor3.run(FORWARD); motor1.run(RELEASE); motor4.run(RELEASE); break; //Stall case '2': motor1.run(RELEASE); motor2.run(RELEASE); motor3.run(RELEASE); motor4.run(RELEASE); break; } }  In a nutshell, the Android device sends Char type to Arduino which is used to rotate the motors to maneuver towards a desired direction.\nForward: 0 Reverse: 1 Stop: 2 Left: 3 Right: 4\nThe car turns left and right by implementing skid steering.\nPictures and Video:\n  ","date":"2014-01-31T11:03:13+05:45","permalink":"https://subedi.ml/posts/rc_car/","section":"posts","tags":["android","arduino"],"title":"Android+Arduino RC Car"},{"categories":null,"contents":"Snakes and Ladders This game needs no introduction. Although there are several variations of this game (mainly on position of the snakes and ladders), the rules are generally the same. Some of the rules, (which are part of my algorithm) are mentioned below. Also, this game requires no skill as it solely depends on luck/probability. This allows several mathematical questions relating to this game be answered using Monte Carlo simulation. However, for this post, I will only be investigating from an analytic/subjective stand point. That is, I will be using Markov Chain to answer those questions. Markov Chain Wikipedia link\nThe game\u0026rsquo;s Markov property or memorylessness allows us to use Markov Chain. That is, the probability of occurrence of next event only depends on current event and not on any other events that occurred before. An example from our game: It does not matter if the player reached square 31 using the ladder from square 9, or by traversing the hard way around. Once the player is in 31, the probability of getting to square 32 does not depend on the \u0026ldquo;past\u0026rdquo;. Transition matrix Wikipedia link Transition matrix is a 2 dimensional array that encapsulates state transitional probabilities. For example, a transition matrix P, given the following information (Mathematical model of one dimensional random walk),\nwould be,\nTransition matrix for Snakes and Ladders Trivial Transition Matrix\nFirst of all, consider a case where there are no snakes or ladders. Let us call this our Trivial (for the lack of words) scenario.\nThis definitely makes for a boring game. However, it helps with the math. First of all, the square 0 is the position the player is before the game starts. Now, since we are using a cubic die, on the first roll, the probability of going from 0 to 1, 0 to 2, 0 to 3, 0 to 4, 0 to 5, and 0 to six is 1/6. Since we are not accounting for snakes or ladders, the probability of going from box i to boxes i+1, i+2, i+3, i+4, i+5, and i+6 are all going to be 1/6, unless we run out of space. That is, if we are at 97, the person can only move to next step if the die rolls 1, 2 or 3. For anything greater, the person will not go to the next step. Therefore, in this case, the probabilities are: 97 to 98 = 1/6, 97 to 99 = 1/6, 97 to 100 = 1/6 and 97 to 97 = 3/6.\nBuilding the Trivial transition matrix based on the aforementioned rule.\n import Jama.Matrix; /** * @return 101X101 Transition Matrix for case: Trivial */ public Matrix trivialMatrix() { int difference, playerPosition = 0, matrixSize=101; double transitionM[][] = new double\\[matrixSize\\][matrixSize]; double probability = 1.0 / 6; for (playerPosition = 0; playerPosition \u0026lt; transitionM.length; playerPosition++) { for (int i = 1; i \u0026lt;= 6; i++) { if ((difference = matrixSize - playerPosition) \u0026lt;= 6) { for (int k = 1; k \u0026lt; difference; k++) { transitionM\\[playerPosition\\][playerPosition + k] = probability; } transitionM\\[playerPosition\\][playerPosition] = (6 - difference + 1) * probability; } else { transitionM\\[playerPosition\\][playerPosition + i] = probability; } } } return new Matrix(transitionM); }  Top-Left\nBottom-Right\nNon-Trivial Transition Matrix\nSnakes:\n98 ~ 78, 95 ~ 75, 93 ~ 73, 87 ~ 24, 64 ~ 60, 62 ~ 19, 56 ~ 53, 49 ~ 11, 48 ~ 26, 16 ~ 6\nLadders:\n1 ~ 38, 4 ~ 14, 9 ~ 31, 21 ~ 42, 28 ~ 84, 36 ~ 44, 51 ~ 67, 71 ~ 91, 80 ~ 100\nI decided to use a simple List implementation for this. This might most likely be the Brute-Force implementation (I know several ways to make it better but none to make it worse). One way to make it more efficient would be to use 82 by 82 matrix instead of 101 by 101.\nThe advantage of using this implementation over the 82 by 82 matrix (apart from easy implementation) is that this method can be used for any snakes and ladders board variation. It also allows us to check for some hypothetical cases or answer more important questions. Eg: What is the best way to position snakes and ladders for maximum thrill to a player?\nBuilding the non-Trivial transition matrix\n /** * @return 101X101 Transition Matrix for case: non-Trivial */ public Matrix nonTrivialMatrix() { int playerPosition,matrixSize=101,difference; List\u0026lt;Integer\u0026gt; from = Arrays.asList(1, 4, 9, 21, 28, 36, 51, 71, 80, 98, 95, 93, 87, 64, 62, 56, 49, 48, 16); List\u0026lt;Integer\u0026gt; to = Arrays.asList(38, 14, 31, 42, 84, 44, 67, 91, 100, 78, 75, 73, 24, 60, 19, 53, 11, 26, 6); double probability = 1.0 / 6; double transitionM[][] = new double\\[matrixSize\\][matrixSize]; for (playerPosition = 0; playerPosition \u0026lt; transitionM.length; playerPosition++) { if (!from.contains(playerPosition)) { for (int i = 1; i \u0026lt;= 6; i++) { if ((difference = 6 - playerPosition) \u0026lt;= 6) { for (int k = 1; k \u0026lt; difference; k++) { if (from.contains(playerPosition + k)) { transitionM\\[playerPosition\\][to.get(from.indexOf(playerPosition + k))] = probability; } else { transitionM\\[playerPosition\\][playerPosition + k] = probability; } } if (from.contains(playerPosition)) { transitionM\\[playerPosition\\][to.get(from.indexOf(playerPosition))] = (6 - difference + 1) * probability; } else { transitionM\\[playerPosition\\][playerPosition] = (6 - difference + 1) * probability; } } else { if (from.contains(playerPosition + i)) { transitionM\\[playerPosition\\][to.get(from.indexOf(playerPosition + i))] = transitionM\\[playerPosition\\][to.get(from.indexOf(playerPosition + i))] + probability; } else { transitionM\\[playerPosition\\][playerPosition + i] = transitionM\\[playerPosition\\][playerPosition + i] + probability; } } } } } return new Matrix(transitionM); }  Top-Left\nBottom-Right\nProbability Vector Wikipedia link\nProbability vectors\nrepresents the probability of being on a certain square after n dice rolls. It is a vector with non-negative entries that add up to one.\nimplies that the probability of being on square 0 is 1. This is our input.\n\u0026hellip;\u0026hellip;\nIf P is the Trivial transition matrix,\nIf P is the non-Trivial transition matrix.\nBuilding the Probability Vector\n /** * @return Probability Vector with 1 being the first element */ public Matrix probabilityVector() { double probabilityV[] = new double[101]; probabilityV[0] = 1; return new Matrix(probabilityV, 1); }  Question 1: Probability of being on square s after n dice rolls: Using Vn-1 * P = Vn\n /** * @param transitionMatrix * @param probabilityVector * @param diceRolls */ public static void squareProbability(Matrix transitionMatrix, Matrix probabilityVector, int diceRolls) { NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(20); System.out.println(\u0026quot;Dice rolls: \u0026quot;+diceRolls); for (int i = 1; i \u0026lt;= diceRolls; i++) { probabilityVector = probabilityVector.times(transitionMatrix); } probabilityVector.print(nf, 3); }  Some outputs for the Trivial matrix: I used html tables to simulate the board (basically printed the html tags within java code).\nSome outputs for the non-Trivial matrix:\nQuestion 2: Minimum length of a game and occurrence probability That is, after how many n, is the probability at square 100 greater than 0 for the first time?\nFor the trivial case, the answer is, ceiling of 100/6 = 17.\nFor the non-trivial case,\n /** * @param transitionMatrix * @param probabilityVector */ public static void gameCompletion(Matrix transitionMatrix, Matrix probabilityVector) { NumberFormat nf = NumberFormat.getInstance(); nf.setMinimumFractionDigits(30); int box = 100; int diceRolls = 0; while (probabilityVector.get(0, box) == 0) { diceRolls++; probabilityVector = probabilityVector.times(transitionMatrix); } System.out.println(\u0026quot;The game can be completed in min of \u0026quot; + diceRolls + \u0026quot; dice rolls.\u0026quot;); System.out.println(\u0026quot;Probability of it happening: \u0026quot; + nf.format(probabilityVector.get(0, box))); }  Results:\nNon-Trivial Matrix\nThe game can be completed in min of 7 dice rolls. Probability of it happening: 0.001564643347050754000000000000  Rolls of {4,6,6,2,6,4,6} is one shortest solution. However, in theory, the game could last forever. Therefore, there is no longest game.\nTrivial Matrix\nThe game can be completed in min of 17 dice rolls. Probability of it happening: 0.000000000009038995585604526000  Rolls of {6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6} is the only shortest solution. Longest game in this case is 100 dice rolls. The player will have to roll 1, 100 consecutive times from start. Question 3: Expected length of a game: Let subStochasticMatrix be the 100 by 100 matrix obtained by deleting the last row and column of the transition matrix. Also, let I be 100 by 100 identity matrix. Let inverse be the inverse of the difference of I and subStochasticMatrix. The expected number of rolls is given by the sum of entries in top row of the matrix inverse.\n /** * @param transitionMatrix * @param probabilityVector */ public static void expectedLength(Matrix transitionMatrix, Matrix probabilityVector){ Matrix subStochasticMatrix=transitionMatrix.getMatrix(0, 99, 0 ,99); Matrix I = Matrix.identity(100,100); Matrix inverse = (I.minus(subStochasticMatrix)).inverse(); double sum=0; for (int i =0;i\u0026lt;=99;i++){ sum=sum+inverse.get(0, i); } System.out.println(\u0026quot;Expected game length: \u0026quot;+sum); }  Results:\nNon-Trivial Matrix\nExpected game length: 39.59836564020812  Trivial Matrix\nExpected game length: 33.33333333333334  ","date":"2013-12-02T10:09:32+05:45","permalink":"https://subedi.ml/posts/snakesandladders/","section":"posts","tags":["markov chains","probability","java"],"title":"Snakes and Ladders"},{"categories":null,"contents":"The Du Compiler: For our Computer Science capstone project, we take on the beast - building a compiler from scratch. We had about three months to do it but we really had no clue of what we were doing for the first month and a half. Although we knew plenty of what there was to know about compilers in theory, we soon realized that building one from scratch was not going to be easy. We started with baby steps, and by the time the project was due, we were taking giant leaps (we had no other option). In the end, it turned out to be a reasonably fine compiler and an excellent experience. During these three months, I had the best and the worst experiences of my academic life. Therefore, this project is really special.\nSince this project belongs to two other people also, I won\u0026rsquo;t be posting any source code. This post will just have some example code for Du-Compiler.\nFinally, for anyone looking for a reasonably challenging senior projects, I would strongly encourage building a compiler. I say this for couple of reasons. First of all, it changes the way we look at code. It gives a better understanding of what exactly happens when the compile button is hit. In another words, it makes you aware of what is going on internally. Secondly, it involves learning/relearning several Computer Science topics such as regular expressions, hash table, data-structures, tree traversals, assembly level programming etc. It also involves A LOT of coding. When it all pans out, you are going to love what you have in your skill set.\nExamples //Hello World duhawk helloworld{ duPrint(%Hello World%); } //Simple Addition duhawk simpleAdd{ int a; a=5; int b; b = a + 5; duPrint b; } //Result: 10 //Simple Pattern duhawk test{ int i; i=1; int j; j=1; while (i\u0026lt;=10){ j=1; while (j\u0026lt;=i){ duPrint(%*%); j=j + 1; } duPrintln(%%); i= i + 1; } } /* Result * ** *** **** ***** ****** ******* ******** ********* ********** */ duhawk test{ int c; int d; duPrint (%Multiplication table of: %); duInput a; duPrint (%upto: %); duInput b; for (c=1;c\u0026lt;=b;c=c + 1){ duPrint a; duPrint (% X %); duPrint c; duPrint (% = %); d = a*c; duPrintln d; } } /* Input for a = 19 Input for b = 15 Result: Multiplication table of: 19 upto: 15 19 X 1 = 19 19 X 2 = 38 19 X 3 = 57 19 X 4 = 76 19 X 5 = 95 19 X 6 = 114 19 X 7 = 133 19 X 8 = 152 19 X 9 = 171 19 X 10 = 190 19 X 11 = 209 19 X 12 = 228 19 X 13 = 247 19 X 14 = 266 19 X 15 = 285 */ ","date":"2013-09-05T17:12:41+05:45","permalink":"https://subedi.ml/posts/ducompiler/","section":"posts","tags":["compiler","java","capstone"],"title":"Compiler from Scratch"},{"categories":null,"contents":"Area of the Mandelbrot Set:  The area of the Mandelbrot Set The Mandelbrot set is a fractal (illustrates self-similarity). The set is obtained from the quadratic recurrence equation,\nwith\n, where points\nin the complex plane for which the orbit of\ndoes not tend to infinity are in the set. The Mandelbrot set is a compact set, contained in the closed disk of radius 2 around the origin. Since it is contained in a disk of known area, it is possible to approximate the area of the Mandelbrot Set\u0026rsquo;s using Monte Carlo method.\n Java: Since Java does not inherently understand complex numbers, a \u0026ldquo;real\u0026rdquo; approach will be applied to perform the quadratic recurrence equation,\nFirst, as shown in the figure above, inscribe the disk in a square of length 4 units. Let\nrepresent the coordinate along x-axis (real) and\nrepresent the coordinate along y axis. Now set\nand\n, where\nand\nare randomly generated real numbers from [-2, 2]. Basically, the\nand\ncoordinates are being duplicated at this step to preserve the point\n. Next, iteratively compute the following from\n(for programming purposes, choose a large Dwell Limit). Simultaneously, check if\n. If yes, increase count (not in the set) by 1 and get out of the loop (since all points should be contained in the disk).\nCompute the ratio of number of points that are in the set to total number of points used. Then multiply the area of square (16 units square) to get the approximate are of the Mandelbrot set.\nJava Code:\nimport java.util.Date; import java.util.Random; public class MandelbrotArea { public static int mcRep = 5000; public static int dwellLimit = 2048; /** * @return random double in [-2,2] */ public static double random() { return (new Random().nextDouble() * 4) - 2; } /** * @param r: real part of the complex number * @param s: imaginary part of the complex number * @return */ public static boolean isMandelbrotSet(double r, double s) { double a = r, b = s, temp; // Iterative function for (int j = 1; j \u0026lt;= dwellLimit; j++) { temp = a; a = Math.pow(a, 2) - Math.pow(b, 2) + r; b = (2 * temp * b) + s; if (Math.pow(a, 2) + Math.pow(b, 2) \u0026gt; 4) { return false; } } return true; } public static void main(String[] args) { long startTime = new Date().getTime(); long count = 0; for (int i = 0; i \u0026lt;= mcRep; i++) { if (isMandelbrotSet(random(), random())) { count++; } } System.out.println(\u0026quot;Input -\u0026gt; DwellLimit: \u0026quot; + dwellLimit + \u0026quot;, McRep: \u0026quot; + mcRep); System.out.println(\u0026quot;Area: \u0026quot; + ((double) (count * 16)) / mcRep); System.out.println(\u0026quot;Execution time: \u0026quot; + (new Date().getTime() - startTime) + \u0026quot; ms\u0026quot;); } }  Result:\nInput -\u0026gt; DwellLimit: 2048, McRep: 5000 Area: 1.5136 Execution time: 389 ms  R\nmonte.Carlo \u0026lt;- 5000 x \u0026lt;- runif(monte.Carlo, -2, 2) y \u0026lt;- runif(monte.Carlo, -2, 2) list \u0026lt;- numeric(monte.Carlo) for (j in 1:monte.Carlo){ list[j] \u0026lt;- if (inmandelbrotset(complex(real = x[j], imaginary = y[j]))) 1 else 0 } area\u0026lt;-mean(list)*16 # function that checks if a point E mandelbrot set inmandelbrotset \u0026lt;- function(c) { dwell.limit \u0026lt;- 2048 z \u0026lt;- 0 for (i in 1:dwell.limit) { z \u0026lt;- z ** 2 + c if (Mod(z) \u0026gt; 2) { return(FALSE) } } return(TRUE) }  ","date":"2013-01-02T10:01:09+05:45","permalink":"https://subedi.ml/posts/mandelbrot_area/","section":"posts","tags":["mandelbrot","java","monte carlo"],"title":"Area of the Mandelbrot Set"},{"categories":null,"contents":"The Faro Shuffle:  A Faro shuffle is probably one of the most intricate skills in an elite magician\u0026rsquo;s arsenal. Although it\u0026rsquo;s simple in concept, it is extremely difficult to perform and it typically needs years and years of practice. The idea of a shuffle is to randomize the cards, and since a typical shuffle is sloppy, that is usually true. However, a Faro shuffle is not random at all. In a perfect shuffle or a Faro shuffle the cards are divided exactly in half (top and bottom) and then interspersed alternately. Twenty one consecutive (out) Faro shuffles for a 50-card deck. However, it only takes eight consecutive Faro shuffles to bring a 52-card deck back to its original order. Interesting. Java: If the number of cards in the deck is 12,\npublic class outFaro { public static void main(String[] args) { // the number of card in the deck int numberofcardindeck = 12; // creating an array of cards int[] deck = new int[numberofcardindeck]; // printing the order of cards in original deck System.out.println(\u0026quot;Original deck\u0026quot;); for (int i = 0; i \u0026lt; numberofcardindeck; i++) { deck[i] = i + 1; System.out.print(deck[i] + \u0026quot; \u0026quot;); } System.out.println(); // dividing the cards in half int[] firsthalfdeck = new int[numberofcardindeck / 2]; int[] secondhalfdeck = new int[numberofcardindeck / 2]; // performing a (out) Faro shuffle for (int Faro = 1; Faro \u0026lt;= 50; Faro++) { for (int i = 0; i \u0026lt; numberofcardindeck / 2; i++) { firsthalfdeck[i] = deck[i]; secondhalfdeck[i] = deck[i + (numberofcardindeck / 2)]; } for (int i = 0; i \u0026lt; numberofcardindeck / 2; i++) { deck[2 * i] = firsthalfdeck[i]; deck[2 * i + 1] = secondhalfdeck[i]; } System.out.println(); System.out.println(\u0026quot;Order under Faro Shuffle: \u0026quot; + Faro); for (int i = 0; i \u0026lt; numberofcardindeck; i++) { System.out.print(deck[i] + \u0026quot; \u0026quot;); } // done when the second card comes back to its original position if (deck[1] == 2) { break; } } } }  Result:\nOriginal deck 1 2 3 4 5 6 7 8 9 10 11 12 Order under Faro Shuffle: 1 1 7 2 8 3 9 4 10 5 11 6 12 Order under Faro Shuffle: 2 1 4 7 10 2 5 8 11 3 6 9 12 Order under Faro Shuffle: 3 1 8 4 11 7 3 10 6 2 9 5 12 Order under Faro Shuffle: 4 1 10 8 6 4 2 11 9 7 5 3 12 Order under Faro Shuffle: 5 1 11 10 9 8 7 6 5 4 3 2 12 Order under Faro Shuffle: 6 1 6 11 5 10 4 9 3 8 2 7 12 Order under Faro Shuffle: 7 1 9 6 3 11 8 5 2 10 7 4 12 Order under Faro Shuffle: 8 1 5 9 2 6 10 3 7 11 4 8 12 Order under Faro Shuffle: 9 1 3 5 7 9 11 2 4 6 8 10 12 Order under Faro Shuffle: 10 1 2 3 4 5 6 7 8 9 10 11 12  After 10 out-Faro shuffles, the card returns to its original permutation. Therefore, 10 is the order of the permutation.\nThe table below shows number of cards in a deck and the number of out-Faro shuffles required to bring it back to its original permutation.\nThe definition of permutation and permutation group:\n“A permutation of a set A is a function from A to A that is both one-to-one and onto. A permutation group of a set A is a set of permutations of A that forms a group under function composition.”\nA Faro Shuffle is one-to-one and onto. At any frequency of the shuffle, every index (1-n) will have a unique card. Also, for every card, there is a unique index regardless of the frequency of the shuffle. The permutation for every “Number of cards” can be thought as a group under the operation - FaroShuffle. Also, since “Number of Faro Shuffles” returns us back to the original permutation, we can establish it as the order of the permutation group.\nTheorem: The order of a permutation of a finite set written in disjoint cycle form is the least common multiple of the lengths of the cycles.The order of a permutation of a finite set written in disjoint cycle form is the least common multiple of the lengths of the cycles.\nThis is one of the most important Group Theory Theorems. Let us consider a 52-card deck to demonstrate this. From the Java code, the order is 8 when n is 52. Instead of looking at disjoint cycle form of the permutation to figure out the order of each element, we can also look at every permutation the original permutation has been to before returning to the original permutation. For n = 52, the table below shows all the permutations.\nFrom the table above, order of 1 and 52 = 1, order of 18 and 35 = 2 and order of rest of the elements = 8 The L.C.M (1,2,8) = 8 is the order of the group according to the Theorem. This is also what we got from the Java code.\nConjectures / Proofs:\nIn-Faro and Out-Faro In an out-Faro shuffle, the top card from first half of the deck always remains on top. In an in-Faro shuffle, the top card from second half will be the new top card of the new shuffled deck.\nSince I did not have a deck of card with me, and I was bored, I wrote a very simple Android app to demonstrate in and out shuffle.\nGenerating a random deck with 4 cards. Notice that the Eight of Hearts is on top.\nOut-Faro 1: Eight of Hearts is on top.\nOut-Faro 2: Eight of Hearts is still on top and the deck is back in its original permutation. Therefore, order = 2.\nIn-Faro 1: Using the same deck, Eight of Hearts is no longer on top.\nIn-Faro 2: Again\u0026hellip;\nIn-Faro 3:\nIn-Faro 4: Back to its original order. Order = 4.\nMore screenshots:\nAnother reason for writing the app was to see the connection between Binary Number System and Faro Shuffle. I read somewhere that magicians and gamblers use this for their advantage.\nConsider a random eight card deck.\nNow, the trick is, to send the Queen of Clubs to say for example, 7th position in the deck (6 cards on top of it), the gambler would perform two in-Faros and one out-Faro. 6 in binary is 110; so, for digit 1, the magician would perform an in-Faro and for 0, an out-Faro.\n1st in-Faro:\n2nd in-Faro:\nout-Faro:\nQueen of Clubs is now in the 7th position. Also, its really interesting that this works irrespective of the number of cards in the deck.\nI also found that the order of (2n+2) out-Faro shuffle is equal to the order of (2n) in-Faro shuffles.\nI find that pretty interesting and I do not really see that to be obvious. It also implies that for no 2n, In-Faro=Out-Faro (I think). I will be investigating on these more later.\n\n","date":"2012-12-05T17:12:41+05:45","permalink":"https://subedi.ml/posts/faro_shuffle/","section":"posts","tags":["faro","java","group theory"],"title":"The Faro Shuffle"}]